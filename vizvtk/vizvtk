#!/usr/bin/vtk

# vizvtk - a little VTK-5.0 application to interactively
#            display and manipulate polygon mesh files.
#
# 	by Tom Bartol 
# 	  (variation on a theme orginally by Will Schroeder)
#

package require vtk
package require vtkinteraction

# Define global variables
set deciReduction 0.0
set deciPreserve 1
set view Top
set Surface 1
set FEdges 0
set BEdges 0
set NMEdges 0
set MEdges 0
set ObjEdges 0
set Compare 0
set edgeSplitting 1
set flipNormals 0

# Instances of vtk objects
vtkPolyData PolyData
#    PolyData GlobalWarningDisplayOff
vtkPolyData PreviousPolyData
vtkPolyData TempPolyData
vtkCellTypes CellTypes

vtkDecimatePro deci
    deci AddObserver StartEvent {StartProgress deci "Decimating..."}
    deci AddObserver ProgressEvent {ShowProgress deci "Decimating..."}
    deci AddObserver EndEvent EndProgress
vtkSmoothPolyDataFilter lsmooth
    lsmooth AddObserver StartEvent {StartProgress lsmooth "Smoothing..."}
    lsmooth AddObserver ProgressEvent {ShowProgress lsmooth "Smoothing..."}
    lsmooth AddObserver EndEvent EndProgress
vtkWindowedSincPolyDataFilter wsmooth
    wsmooth AddObserver StartEvent {StartProgress wsmooth "Smoothing..."}
    wsmooth AddObserver ProgressEvent {ShowProgress wsmooth "Smoothing..."}
    wsmooth AddObserver EndEvent EndProgress
vtkLinearSubdivisionFilter lsubdiv
    lsubdiv AddObserver StartEvent {StartProgress lsubdiv "Subdividing..."}
    lsubdiv AddObserver ProgressEvent {ShowProgress lsubdiv "Subdividing..."}
    lsubdiv AddObserver EndEvent EndProgress
vtkButterflySubdivisionFilter bsubdiv
    bsubdiv AddObserver StartEvent {StartProgress bsubdiv "Subdividing..."}
    bsubdiv AddObserver ProgressEvent {ShowProgress bsubdiv "Subdividing..."}
    bsubdiv AddObserver EndEvent EndProgress
vtkCleanPolyData cleaner
    cleaner AddObserver StartEvent {StartProgress cleaner "Cleaning..."}
    cleaner AddObserver ProgressEvent {ShowProgress cleaner "Cleaning..."}
    cleaner AddObserver EndEvent EndProgress
vtkPolyDataConnectivityFilter connect
    connect AddObserver StartEvent {StartProgress connect "Connectivity..."}
    connect AddObserver ProgressEvent {ShowProgress connect "Connectivity..."}
    connect AddObserver EndEvent EndProgress
vtkTriangleFilter tri
    tri AddObserver StartEvent {StartProgress tri "Triangulating..."}
    tri AddObserver ProgressEvent {ShowProgress tri "Triangulating..."}
    tri AddObserver EndEvent EndProgress
vtkPolyDataNormals normals
    normals AddObserver StartEvent {StartProgress normals "Generating Normals..."}
    normals AddObserver ProgressEvent {ShowProgress normals "Generating Normals..."}
    normals AddObserver EndEvent EndProgress
vtkStripper stripper
    stripper AddObserver StartEvent {StartProgress stripper "Generating Triangle Strips..."}
    stripper AddObserver ProgressEvent {ShowProgress stripper "Generating Triangle Strips..."}
    stripper AddObserver EndEvent EndProgress


######################################## Create top-level GUI
#
wm title . "VizVTK v1.0"
frame .mbar -relief raised -bd 2
pack .mbar -side top -fill x

menubutton .mbar.file -text File -menu .mbar.file.menu
menubutton .mbar.edit -text Edit -menu .mbar.edit.menu
menubutton .mbar.view -text View -menu .mbar.view.menu
menubutton .mbar.options -text Options -menu .mbar.options.menu
menubutton .mbar.help -text Help -menu .mbar.help.menu
pack .mbar.file .mbar.edit .mbar.view .mbar.options -side left
pack .mbar.help -side right

menu .mbar.file.menu
    .mbar.file.menu add command -label Open -command OpenFile -state normal
    .mbar.file.menu add command -label Save -command SaveFile -state disabled
    .mbar.file.menu add command -label Exit -command exit -state normal

menu .mbar.edit.menu
    .mbar.edit.menu add command -label Clean -command Clean -state disabled
    .mbar.edit.menu add command -label Connectivity -command Connect -state disabled
    .mbar.edit.menu add command -label Decimate -command Decimate -state disabled
    .mbar.edit.menu add command -label Normals -command Normals -state disabled
    .mbar.edit.menu add command -label "Laplacian Smooth" -command LSmooth -state disabled
    .mbar.edit.menu add command -label "Windowed Sinc Smooth" -command WSmooth -state disabled
    .mbar.edit.menu add command -label "Linear Subdivision" -command LSubdiv -state disabled
    .mbar.edit.menu add command -label "Butterfly Subdivision" -command BSubdiv -state disabled
    .mbar.edit.menu add command -label Triangulate -command Triangulate \
	    -state disabled
    .mbar.edit.menu add command -label "Triangle Strips" -command Stripper -state disabled
    .mbar.edit.menu add command -label "Undo/Redo" -command Undo

menu .mbar.view.menu
    .mbar.view.menu add checkbutton -label "Object Surface" -variable Surface\
	    -command UpdateGUI
    .mbar.view.menu add checkbutton -label "Feature Edges" -variable FEdges\
	    -command UpdateGUI
    .mbar.view.menu add checkbutton -label "Boundary Edges" -variable BEdges\
	    -command UpdateGUI
    .mbar.view.menu add checkbutton -label "Non-manifold Edges" -variable NMEdges\
	    -command UpdateGUI
    .mbar.view.menu add checkbutton -label "Manifold Edges" -variable MEdges\
	    -command UpdateGUI
    .mbar.view.menu add separator
    .mbar.view.menu add radiobutton -label Front -variable view -value Front\
            -command {UpdateView 1 0 0 0 1 0}
    .mbar.view.menu add radiobutton -label Back -variable view -value Back\
            -command {UpdateView -1 0 0 0 1 0}
    .mbar.view.menu add radiobutton -label Left -variable view -value Left\
            -command {UpdateView 0 0 1 0 1 0}
    .mbar.view.menu add radiobutton -label Right -variable view -value Right\
            -command {UpdateView 0 0 -1 0 1 0}
    .mbar.view.menu add radiobutton -label Top -variable view -value Top\
            -command {UpdateView 0 1 0 0 0 1}
    .mbar.view.menu add radiobutton -label Bottom -variable view -value Bottom\
            -command {UpdateView 0 -1 0 0 0 1}
    .mbar.view.menu add radiobutton -label Isometric -variable view \
        -value Isometric -command {UpdateView 1 1 1 0 1 0}

menu .mbar.options.menu
    .mbar.options.menu add command -label "Compare Results" -command Compare \
	    -state disabled
    .mbar.options.menu add command -label "Background Color..." \
	    -command BackgroundColor
    .mbar.options.menu add command -label "Front Surface Properties..." \
	    -command FrontProperties
    .mbar.options.menu add command -label "Back Surface Properties..." \
	    -command BackProperties
    .mbar.options.menu add command -label "Edge Color..." \
	    -command EdgeColor

menu .mbar.help.menu
    .mbar.help.menu add command -label {Are you kidding?}

# create the rendering widget
vtkRenderWindow renWin
vtkTkRenderWidget .window -width 900 -height 600 -rw renWin
::vtk::bind_tk_render_widget .window

set iren [renWin GetInteractor]
set istyle [vtkInteractorStyleSwitch istyleswitch]
$iren SetInteractorStyle $istyle
$istyle SetCurrentStyleToTrackballCamera

pack .window -side top -anchor nw -padx 3 -pady 3 -fill both -expand 1

# Status bar
frame .bottomF -relief sunken -borderwidth 3
label .bottomF.status -text "(No data)" -borderwidth 0
pack .bottomF.status -side top -anchor w -expand 1 -fill x -padx 0 -pady 0
pack .bottomF  -side top -anchor w -expand 1 -fill x -padx 0 -pady 0

# Graphics objects
vtkCamera camera
vtkLight light
light SetLightTypeToHeadlight
vtkRenderer Renderer
    Renderer SetActiveCamera camera
    Renderer AddLight light
vtkRenderer CompareRenderer
    CompareRenderer SetViewport 0.0 0.0 0.5 1.0
    CompareRenderer SetActiveCamera camera
    CompareRenderer AddLight light
set RenWin [.window GetRenderWindow]
$RenWin AddRenderer Renderer

# Procedure to set particular views
proc UpdateView {x y z vx vy vz} {
    global RenWin

    set camera [Renderer GetActiveCamera]
#    $camera SetViewPlaneNormal $x $y $z
    $camera SetViewUp $vx $vy $vz
    Renderer ResetCamera
    $RenWin Render
}

# Procedure opens file and resets view
proc OpenFile {} {
    global RenWin CurrentFilter

    set types {
        {{Visualization Toolkit (polygonal)}    {.vtk}        }
        {{Marching Cubes}                       {.tri}        }
        {{BYU}                                  {.g}          }
        {{Cyberware (Laser Scanner)}            {.cyb}        }
        {{Stereo-Lithography}                   {.stl}        }
        {{Wavefront}                            {.obj}        }
        {{All Files }                           *             }
    }
    set filename [tk_getOpenFile -filetypes $types]
    if { $filename != "" } {
        if { [info commands reader] != "" } {reader Delete}
        if { [string match *.g $filename] } {
            vtkBYUReader reader
            reader SetGeometryFileName $filename
        } elseif { [string match *.stl $filename] } {
            vtkSTLReader reader
            reader SetFileName $filename
        } elseif { [string match *.vtk $filename] } {
            vtkPolyDataReader reader
            reader SetFileName $filename
        } elseif { [string match *.cyb $filename] } {
            vtkCyberReader reader
            reader SetFileName $filename
        } elseif { [string match *.tri $filename] } {
            vtkMCubesReader reader
            reader SetFileName $filename
        } elseif { [string match *.obj $filename] } {
            vtkOBJReader reader
            reader SetFileName $filename
        } else {
            puts "Can't read this file"
            return
        }

        reader AddObserver StartEvent {StartProgress reader "Reading..."}
        reader AddObserver ProgressEvent {ShowProgress reader "Reading..."}
        reader AddObserver EndEvent EndProgress

	UpdateView 0 1 0 0 0 1
        UpdateUndo "reader"
	UpdateGUI

	set filename "VizVTK: [file tail $filename]"
	wm title . $filename

        Renderer ResetCamera
        $RenWin Render
    }
}

# Procedure saves data to file
proc SaveFile {} {
    global PolyData RenWin

    set types {
        {{Visualization Toolkit (polygonal)}    {.vtk}        }
        {{PNG image}                            {.png}        }
        {{Marching Cubes}                       {.tri}        }
        {{BYU}                                  {.g}          }
        {{RIB (Renderman)}                      {.rib}        }
        {{Stereo-Lithography}                   {.stl}        }
        {{VRML}                                 {.wrl}        }
        {{Wavefront OBJ}                        {.obj}        }
        {{All Files }                           *             }
    }
    set filename [tk_getSaveFile -filetypes $types]
    if { $filename != "" } {
        if { [info commands writer] != "" } {writer Delete}
        if { [string match *.g $filename] } {
            vtkBYUWriter writer
            writer SetGeometryFileName $filename
            writer SetInput PolyData
        } elseif { [string match *.stl $filename] } {
            vtkSTLWriter writer
            writer SetFileName $filename
            writer SetInput PolyData
        } elseif { [string match *.vtk $filename] } {
            vtkPolyDataWriter writer
            writer SetFileName $filename
            writer SetInput PolyData
        } elseif { [string match *.tri $filename] } {
            vtkMCubesWriter writer
            writer SetFileName $filename
            writer SetInput PolyData
        } elseif { [string match *.wrl $filename] } {
            vtkVRMLExporter writer
	    writer SetRenderWindow $RenWin
            writer SetFileName $filename
        } elseif { [string match *.obj $filename] } {
            vtkOBJExporter writer
	    writer SetRenderWindow $RenWin
            writer SetFilePrefix [file rootname $filename]
        } elseif { [string match *.rib $filename] } {
            vtkRIBExporter writer
	    writer SetRenderWindow $RenWin
            writer SetFilePrefix [file rootname $filename]
        } elseif { [string match *.png $filename] } {
            if { [info commands w2if] != "" } {w2if Delete}
	    vtkWindowToImageFilter w2if
	    vtkPNGWriter writer
	    w2if SetInput $RenWin
	    writer SetInput [ w2if GetOutput ]
	    writer SetFileName $filename
        } else {
            puts "Can't write this file"
            return
        }
        
        writer Write
    }
}

# Enable the undo procedure after filter execution
proc UpdateUndo {filter} {
    global CurrentFilter

    set CurrentFilter $filter
    $filter Update

    PreviousPolyData CopyStructure PolyData
    [PreviousPolyData GetPointData] PassData [PolyData GetPointData]
    PreviousPolyData Modified

    PolyData CopyStructure [$filter GetOutput]
    [PolyData GetPointData] PassData [[$filter GetOutput] GetPointData]
    PolyData Modified

    ReleaseData
}

# Undo last edit
proc Undo {} {
    global RenWin

    TempPolyData CopyStructure PolyData
    [TempPolyData GetPointData] PassData [PolyData GetPointData]

    PolyData CopyStructure PreviousPolyData
    [PolyData GetPointData] PassData [PreviousPolyData GetPointData]
    PolyData Modified

    PreviousPolyData CopyStructure TempPolyData
    [PreviousPolyData GetPointData] PassData [TempPolyData GetPointData]
    PreviousPolyData Modified

    UpdateGUI
    $RenWin Render
}

### Procedure initializes filters so that they release their memory
#
proc ReleaseData {} {
    [deci GetOutput] Initialize
    [lsmooth GetOutput] Initialize
    [wsmooth GetOutput] Initialize
    [lsubdiv GetOutput] Initialize
    [bsubdiv GetOutput] Initialize
    [cleaner GetOutput] Initialize
    [connect GetOutput] Initialize
    [tri GetOutput] Initialize
    [stripper GetOutput] Initialize
}

#### Create pipeline
vtkPolyDataMapper   mapper
    mapper SetInput PolyData
vtkProperty frontProperty
    frontProperty SetColor 0.8900 0.8100 0.3400
    frontProperty SetSpecularColor 1 1 1
    frontProperty SetSpecular 0.3
    frontProperty SetSpecularPower 20
    frontProperty SetAmbient 0.2
    frontProperty SetDiffuse 0.8
    frontProperty EdgeVisibilityOn
vtkProperty backProperty
    backProperty SetColor 0.8900 0.0 0.0
    backProperty SetSpecularColor 1 1 1
    backProperty SetSpecular 0.3
    backProperty SetSpecularPower 20
    backProperty SetAmbient 0.2
    backProperty SetDiffuse 0.8
    backProperty EdgeVisibilityOn
vtkActor actor
    actor SetMapper mapper
    actor SetProperty frontProperty
    actor SetBackfaceProperty backProperty

# Welcome banner
vtkVectorText banner
    banner SetText "     VizVTK"
vtkPolyDataMapper bannerMapper
    bannerMapper SetInput [banner GetOutput]
vtkActor bannerActor
    bannerActor SetMapper bannerMapper
    bannerActor SetProperty frontProperty
    bannerActor SetBackfaceProperty backProperty

# Actor used for side-by-side data comparison
vtkPolyDataMapper CompareMapper
    CompareMapper SetInput PreviousPolyData
vtkActor CompareActor
    CompareActor SetMapper CompareMapper
    CompareActor SetProperty frontProperty
    CompareActor SetBackfaceProperty backProperty
CompareRenderer AddActor CompareActor

# Edges
vtkFeatureEdges FeatureEdges
    FeatureEdges SetInput PolyData
    FeatureEdges BoundaryEdgesOff
    FeatureEdges NonManifoldEdgesOff
    FeatureEdges ManifoldEdgesOff
    FeatureEdges FeatureEdgesOff
vtkPolyDataMapper FEdgesMapper
    FEdgesMapper SetInput [FeatureEdges GetOutput]
vtkActor FEdgesActor
    FEdgesActor SetMapper FEdgesMapper

Renderer AddActor bannerActor
Renderer ResetCamera
[Renderer GetActiveCamera] Zoom 1.25

# Procedure updates data statistics and GUI menus
#
proc UpdateGUI {} {
    global Surface RenWin
    global FEdges BEdges NMEdges MEdges RenWin

    set NumberOfNodes [PolyData GetNumberOfPoints]
    set NumberOfElements [PolyData GetNumberOfCells]
    PolyData GetCellTypes CellTypes

    Renderer RemoveActor bannerActor
    Renderer RemoveActor actor
    Renderer RemoveActor FEdgesActor

    # Check to see whether to add surface model
    if { [PolyData GetNumberOfCells] <= 0 } {
	Renderer AddActor bannerActor
	.mbar.file.menu entryconfigure 2 -state disabled
	.mbar.edit.menu entryconfigure 1 -state disabled
	.mbar.edit.menu entryconfigure 2 -state disabled
	.mbar.edit.menu entryconfigure 3 -state disabled
	.mbar.edit.menu entryconfigure 4 -state disabled
	.mbar.edit.menu entryconfigure 5 -state disabled
	.mbar.edit.menu entryconfigure 6 -state disabled
	.mbar.edit.menu entryconfigure 7 -state disabled
	.mbar.edit.menu entryconfigure 8 -state disabled
	.mbar.edit.menu entryconfigure 9 -state disabled
	.mbar.options.menu entryconfigure 1 -state disabled
        set s "(None)"

    } else {
	if { $Surface } {Renderer AddActor actor}

	if { $FEdges || $BEdges || $NMEdges || $MEdges } {
	    Renderer AddActor FEdgesActor
	    FeatureEdges SetBoundaryEdges $BEdges
	    FeatureEdges SetFeatureEdges $FEdges
	    FeatureEdges SetNonManifoldEdges $NMEdges
	    FeatureEdges SetManifoldEdges $MEdges
	}

	.mbar.file.menu entryconfigure 2 -state normal
	.mbar.edit.menu entryconfigure 1 -state normal
        if { [CellTypes GetNumberOfTypes] != 1 || [CellTypes GetCellType 0] != 5 } {
	    .mbar.edit.menu entryconfigure 2 -state disabled
            .mbar.edit.menu entryconfigure 9 -state normal
            set s [format "Vertices:%d    Cells:%d" \
                   $NumberOfNodes $NumberOfElements]
	} else {
            .mbar.edit.menu entryconfigure 2 -state normal
            .mbar.edit.menu entryconfigure 9 -state disabled
            set s [format "Vertices:%d    Triangles:%d" \
                   $NumberOfNodes $NumberOfElements]
	}
	.mbar.edit.menu entryconfigure 3 -state normal
	.mbar.edit.menu entryconfigure 4 -state normal
	.mbar.edit.menu entryconfigure 5 -state normal
	.mbar.edit.menu entryconfigure 6 -state normal
	.mbar.edit.menu entryconfigure 7 -state normal
	.mbar.edit.menu entryconfigure 8 -state normal
	.mbar.edit.menu entryconfigure 10 -state normal
	.mbar.options.menu entryconfigure 1 -state normal
    }

    .bottomF.status configure -text $s
}

### Procedure manages splitting screen and comparing data
#
proc Compare {} {
    global Compare RenWin

    if { $Compare == 0} {
	$RenWin AddRenderer CompareRenderer
	Renderer SetViewport 0.5 0.0 1.0 1.0
	.mbar.options.menu entryconfigure 1 -label "Uncompare Results"
	set Compare 1

    } else {
	$RenWin RemoveRenderer CompareRenderer
	Renderer SetViewport 0.0 0.0 1.0 1.0
	.mbar.options.menu entryconfigure 1 -label "Compare Results"
	set Compare 0
    }

    $RenWin Render
}

########################## The decimation GUI
#
# Procedure defines GUI and behavior for decimating data
#
proc Decimate {} {
    UpdateDecimationGUI
    wm deiconify .decimate
}

proc CloseDecimate {} {
    wm withdraw .decimate
}

toplevel .decimate
wm withdraw .decimate
wm title .decimate "Decimate"
wm protocol .decimate WM_DELETE_WINDOW {wm withdraw .decimate}

frame .decimate.f1
checkbutton .decimate.f1.preserve -variable deciPreserve \
	-text "Preserve Topology"
scale .decimate.f1.red -label "Requested Number Of Polygons" \
	-from 0 -to 100000 -length 3.0i -orient horizontal \
	-resolution 1 -command SetDeciPolygons
.decimate.f1.red set 4000
pack .decimate.f1.preserve .decimate.f1.red \
	-pady 0.1i -side top -anchor w

frame .decimate.fb
button .decimate.fb.apply -text Apply -command ApplyDecimation
button .decimate.fb.cancel -text Cancel -command CloseDecimate
pack .decimate.fb.apply .decimate.fb.cancel -side left -expand 1 -fill x
pack .decimate.f1 .decimate.fb -side top -fill both -expand 1

proc UpdateDecimationGUI {} {

   set numPolys [PolyData GetNumberOfCells]
   .decimate.f1.red configure -to $numPolys

   SetDeciPolygons [.decimate.f1.red get]
}

proc ApplyDecimation {} {
    global deciReduction deciPreserve RenWin

    deci SetInput PolyData    

    deci SetTargetReduction $deciReduction
    deci SetPreserveTopology $deciPreserve

    UpdateUndo "deci"
    UpdateGUI

    $RenWin Render
    CloseDecimate
}  

proc SetDeciPolygons value {
    global deciReduction

    set numInPolys [PolyData GetNumberOfCells]
    if { $numInPolys <= 0 } {return}
    set deciReduction [expr (double($numInPolys) - $value) / $numInPolys]
}

########################## The lsmooth poly data GUI
#
# Procedure defines GUI and behavior for Laplacian smoothing of data.
#
proc LSmooth {} {
    UpdateLSmoothGUI
    wm deiconify .lsmooth
}

proc CloseLSmooth {} {
    wm withdraw .lsmooth
}

toplevel .lsmooth
wm withdraw .lsmooth
wm title .lsmooth "Laplacian Smooth"
wm protocol .lsmooth WM_DELETE_WINDOW {wm withdraw .lsmooth}

frame .lsmooth.f1
scale .lsmooth.f1.num -label "Number of Iterations" \
	-from 1 -to 1000 -length 3.0i -orient horizontal \
	-resolution 1
.lsmooth.f1.num set 50
scale .lsmooth.f1.fact -label "Relaxation Factor" \
	-from 0.00 -to 1.00 -length 3.0i -orient horizontal \
	-resolution 0.01
.lsmooth.f1.fact set 0.01
lsmooth SetNumberOfIterations [.lsmooth.f1.num get]
lsmooth SetRelaxationFactor [.lsmooth.f1.fact get]
pack .lsmooth.f1.num .lsmooth.f1.fact \
	-pady 0.1i -side top -anchor w

frame .lsmooth.fb
button .lsmooth.fb.apply -text Apply -command ApplyLSmooth
button .lsmooth.fb.cancel -text Cancel -command CloseLSmooth
pack .lsmooth.fb.apply .lsmooth.fb.cancel -side left -expand 1 -fill x
pack .lsmooth.f1 .lsmooth.fb -side top -fill both -expand 1

proc UpdateLSmoothGUI {} {

   .lsmooth.f1.num set [lsmooth GetNumberOfIterations]
   .lsmooth.f1.fact set [lsmooth GetRelaxationFactor]
}

proc ApplyLSmooth {} {
    global RenWin

    lsmooth SetInput PolyData    

    lsmooth SetNumberOfIterations [.lsmooth.f1.num get]
    lsmooth SetRelaxationFactor [.lsmooth.f1.fact get]
    lsmooth FeatureEdgeSmoothingOff

    UpdateUndo "lsmooth"
    UpdateGUI

    $RenWin Render
    CloseLSmooth
}  


########################## The Windowed Sinc Smoothing GUI
#
# Procedure defines GUI and behavior for windowed sinc smoothing of data.
#
proc WSmooth {} {
    UpdateWSmoothGUI
    wm deiconify .wsmooth
}

proc CloseWSmooth {} {
    wm withdraw .wsmooth
}

toplevel .wsmooth
wm withdraw .wsmooth
wm title .wsmooth "Windowed Sinc Smooth"
wm protocol .wsmooth WM_DELETE_WINDOW {wm withdraw .wsmooth}

frame .wsmooth.f1
scale .wsmooth.f1.num -label "Number of Iterations" \
	-from 1 -to 1000 -length 3.0i -orient horizontal \
	-resolution 1
.wsmooth.f1.num set 20
scale .wsmooth.f1.pb -label "Pass Band" \
	-from 0.00 -to 2.00 -length 3.0i -orient horizontal \
	-resolution 0.01
.wsmooth.f1.pb set 0.1
wsmooth SetNumberOfIterations [.wsmooth.f1.num get]
wsmooth SetPassBand [.wsmooth.f1.pb get]
pack .wsmooth.f1.num .wsmooth.f1.pb \
	-pady 0.1i -side top -anchor w

frame .wsmooth.fb
button .wsmooth.fb.apply -text Apply -command ApplyWSmooth
button .wsmooth.fb.cancel -text Cancel -command CloseWSmooth
pack .wsmooth.fb.apply .wsmooth.fb.cancel -side left -expand 1 -fill x
pack .wsmooth.f1 .wsmooth.fb -side top -fill both -expand 1

proc UpdateWSmoothGUI {} {

   .wsmooth.f1.num set [wsmooth GetNumberOfIterations]
   .wsmooth.f1.pb set [wsmooth GetPassBand]
}

proc ApplyWSmooth {} {
    global RenWin

    wsmooth SetInput PolyData    

    wsmooth SetNumberOfIterations [.wsmooth.f1.num get]
    wsmooth SetPassBand [.wsmooth.f1.pb get]
    wsmooth FeatureEdgeSmoothingOff

    UpdateUndo "wsmooth"
    UpdateGUI

    $RenWin Render
    CloseWSmooth
}  


########################## The lsubdiv GUI
#
# Procedure defines GUI and behavior for linear subdivision of data.
#
proc LSubdiv {} {
    UpdateLSubdivGUI
    wm deiconify .lsubdiv
}

proc CloseLSubdiv {} {
    wm withdraw .lsubdiv
}

toplevel .lsubdiv
wm withdraw .lsubdiv
wm title .lsubdiv "Linear Subdivision"
wm protocol .lsubdiv WM_DELETE_WINDOW {wm withdraw .lsubdiv}

frame .lsubdiv.f1
scale .lsubdiv.f1.num -label "Number of Subdivisions" \
	-from 1 -to 4 -length 3.0i -orient horizontal \
	-resolution 1
.lsubdiv.f1.num set 1
lsubdiv SetNumberOfSubdivisions [.lsubdiv.f1.num get]
pack .lsubdiv.f1.num \
	-pady 0.1i -side top -anchor w

frame .lsubdiv.fb
button .lsubdiv.fb.apply -text Apply -command ApplyLSubdiv
button .lsubdiv.fb.cancel -text Cancel -command CloseLSubdiv
pack .lsubdiv.fb.apply .lsubdiv.fb.cancel -side left -expand 1 -fill x
pack .lsubdiv.f1 .lsubdiv.fb -side top -fill both -expand 1

proc UpdateLSubdivGUI {} {

   .lsubdiv.f1.num set [lsubdiv GetNumberOfSubdivisions]
}

proc ApplyLSubdiv {} {
    global RenWin

    lsubdiv SetInput PolyData    

    lsubdiv SetNumberOfSubdivisions [.lsubdiv.f1.num get]

    UpdateUndo "lsubdiv"
    UpdateGUI

    $RenWin Render
    CloseLSubdiv
}  


########################## The bsubdiv GUI
#
# Procedure defines GUI and behavior for butterfly subdivision of data.
#
proc BSubdiv {} {
    UpdateBSubdivGUI
    wm deiconify .bsubdiv
}

proc CloseBSubdiv {} {
    wm withdraw .bsubdiv
}

toplevel .bsubdiv
wm withdraw .bsubdiv
wm title .bsubdiv "Butterfly Subdivision"
wm protocol .bsubdiv WM_DELETE_WINDOW {wm withdraw .bsubdiv}

frame .bsubdiv.f1
scale .bsubdiv.f1.num -label "Number of Subdivisions" \
	-from 1 -to 4 -length 3.0i -orient horizontal \
	-resolution 1
.bsubdiv.f1.num set 1
bsubdiv SetNumberOfSubdivisions [.bsubdiv.f1.num get]
pack .bsubdiv.f1.num \
	-pady 0.1i -side top -anchor w

frame .bsubdiv.fb
button .bsubdiv.fb.apply -text Apply -command ApplyBSubdiv
button .bsubdiv.fb.cancel -text Cancel -command CloseBSubdiv
pack .bsubdiv.fb.apply .bsubdiv.fb.cancel -side left -expand 1 -fill x
pack .bsubdiv.f1 .bsubdiv.fb -side top -fill both -expand 1

proc UpdateBSubdivGUI {} {

   .bsubdiv.f1.num set [bsubdiv GetNumberOfSubdivisions]
}

proc ApplyBSubdiv {} {
    global RenWin

    bsubdiv SetInput PolyData    

    bsubdiv SetNumberOfSubdivisions [.bsubdiv.f1.num get]

    UpdateUndo "bsubdiv"
    UpdateGUI

    $RenWin Render
    CloseBSubdiv
}  


########################## The clean GUI
#
# Procedure defines GUI and behavior for cleaning data. Cleaning means
# removing degenerate polygons and eliminating coincident or unused points.
#
proc Clean {} {
    UpdateCleanGUI
    wm deiconify .clean
}
proc CloseClean {} {
    wm withdraw .clean
}

toplevel .clean
wm withdraw .clean
wm title .clean "Clean Data"
wm protocol .clean WM_DELETE_WINDOW {wm withdraw .clean}

frame .clean.f1
scale .clean.f1.s -label "Tolerance" \
	-from 0.000 -to 1.000 -length 3.0i -orient horizontal\
	-resolution 0.001 -digits 3
.clean.f1.s set 0.000
pack .clean.f1.s -side top -anchor w

frame .clean.fb
button .clean.fb.apply -text Apply -command ApplyClean
button .clean.fb.cancel -text Cancel -command CloseClean
pack .clean.fb.apply .clean.fb.cancel -side left -expand 1 -fill x
pack .clean.f1 .clean.fb -side top -fill both -expand 1

proc UpdateCleanGUI {} {
    .clean.f1.s set [cleaner GetTolerance]
}

proc ApplyClean {} {
    global RenWin

    cleaner SetInput PolyData
    cleaner SetTolerance [.clean.f1.s get]

    UpdateUndo "cleaner"
    UpdateGUI

    $RenWin Render
    CloseClean
}
########################## The connectivity GUI
#
# Procedure defines GUI and behavior for extracting connected data. Connecting
# means extracting all cells joined at a vertex.
#
proc Connect {} {
    UpdateConnectGUI
    wm deiconify .connect
}
proc CloseConnect {} {
    wm withdraw .connect
}

toplevel .connect
wm withdraw .connect
wm title .connect "Extract Connected Data"
wm protocol .connect WM_DELETE_WINDOW {wm withdraw .connect}

frame .connect.fb
button .connect.fb.apply -text Apply -command ApplyConnect
button .connect.fb.cancel -text Cancel -command CloseConnect
pack .connect.fb.apply .connect.fb.cancel -side left -expand 1 -fill x
pack .connect.fb -side top -fill both -expand 1

proc UpdateConnectGUI {} {
}

proc ApplyConnect {} {
    global RenWin

    connect SetInput PolyData

    UpdateUndo "connect"
    UpdateGUI

    $RenWin Render
    CloseConnect
}

########################## The triangulate GUI
#
# Procedure defines GUI and behavior for triangulating data. This will
# convert all polygons into triangles.
#
proc Triangulate {} {
    UpdateTriGUI
    wm deiconify .tri
}
proc CloseTri {} {
    wm withdraw .tri
}

toplevel .tri
wm withdraw .tri
wm title .tri "Triangulate Data"
wm protocol .tri WM_DELETE_WINDOW {wm withdraw .tri}

frame .tri.fb
button .tri.fb.apply -text Apply -command ApplyTri
button .tri.fb.cancel -text Cancel -command CloseTri
pack .tri.fb.apply .tri.fb.cancel -side left -expand 1 -fill x
pack .tri.fb -side top -fill both -expand 1

proc UpdateTriGUI {} {
}

proc ApplyTri {} {
    global RenWin

    tri SetInput PolyData

    UpdateUndo "tri"
    UpdateGUI

    $RenWin Render
    CloseTri
}

########################## The triangle stripper GUI
#
# Procedure defines GUI and behavior for converting data to triangle strips.
#
proc Stripper {} {
    UpdateStripperGUI
    wm deiconify .stripper
}
proc CloseStripper {} {
    wm withdraw .stripper
}

toplevel .stripper
wm withdraw .stripper
wm title .stripper "Triangle Stripper"
wm protocol .stripper WM_DELETE_WINDOW {wm withdraw .stripper}

frame .stripper.fb
button .stripper.fb.apply -text Apply -command ApplyStripper
button .stripper.fb.cancel -text Cancel -command CloseStripper
pack .stripper.fb.apply .stripper.fb.cancel -side left -expand 1 -fill x
pack .stripper.fb -side top -fill both -expand 1

proc UpdateStripperGUI {} {
}

proc ApplyStripper {} {
    global RenWin

    stripper SetInput PolyData

    UpdateUndo "stripper"
    UpdateGUI

    $RenWin Render
    CloseStripper
}

########################## The surface normals GUI
#
# Procedure defines GUI and behavior for generating surface normals. This will
# convert all polygons into triangles.
#
proc Normals {} {
    UpdateNormalsGUI
    wm deiconify .normals
}
proc CloseNormals {} {
    wm withdraw .normals
}

toplevel .normals
wm withdraw .normals
wm title .normals "Generate Surface Normals"
wm protocol .normals WM_DELETE_WINDOW {wm withdraw .normals}

frame .normals.f1
scale .normals.f1.fangle -label "Feature Angle" \
	-from 0 -to 180 -length 3.0i -orient horizontal -resolution 1
checkbutton .normals.f1.split -variable edgeSplitting \
	-text "Edge Splitting"
checkbutton .normals.f1.flip -variable flipNormals \
	-text "Flip Normals"
pack .normals.f1.fangle .normals.f1.split .normals.f1.flip \
	-pady 0.1i -side top -anchor w

frame .normals.fb
button .normals.fb.apply -text Apply -command ApplyNormals
button .normals.fb.cancel -text Cancel -command CloseNormals
pack .normals.fb.apply .normals.fb.cancel -side left -expand 1 -fill x
pack .normals.f1 .normals.fb -side top -fill both -expand 1

proc UpdateNormalsGUI {} {
    .normals.f1.fangle set [normals GetFeatureAngle]
}

proc ApplyNormals {} {
    global edgeSplitting flipNormals
    global RenWin

    normals SetFeatureAngle [.normals.f1.fangle get]
    normals SetSplitting $edgeSplitting
    normals SetFlipNormals $flipNormals

    normals SetInput PolyData

    UpdateUndo "normals"
    UpdateGUI

    $RenWin Render
    CloseNormals
}

############################ Setting background color
##
proc BackgroundColor {} {

    set background [Renderer GetBackground]
    .back.f1.l.r set [expr [lindex $background 0] * 255.0]
    .back.f1.l.g set [expr [lindex $background 1] * 255.0]
    .back.f1.l.b set [expr [lindex $background 2] * 255.0]
    wm deiconify .back
}

proc CloseBackground {} {
    wm withdraw .back
}

toplevel .back
wm withdraw .back
wm title .back "Select Background Color"
wm protocol .back WM_DELETE_WINDOW {wm withdraw .back}
frame .back.f1

frame .back.f1.l  -relief raised -borderwidth 3
scale .back.f1.l.r -from 255 -to 0 -orient vertical -background #f00 \
	-command SetBackgroundColor
scale .back.f1.l.g -from 255 -to 0 -orient vertical -background #0f0 \
	-command SetBackgroundColor
scale .back.f1.l.b -from 255 -to 0 -orient vertical -background #00f \
	-command SetBackgroundColor
pack .back.f1.l.r .back.f1.l.g .back.f1.l.b -side left -fill both

frame .back.f1.m -relief raised -borderwidth 3
label .back.f1.m.sample -highlightthickness 0 -text "  Background Color  "
pack .back.f1.m.sample -fill both -expand 1

frame .back.f1.r -relief raised -borderwidth 3
image create photo ColorWheel -file /usr/local/pkgs/vizvtk/lib/ColorWheel.ppm
label .back.f1.r.wheel -image ColorWheel -highlightthickness 0
bind .back.f1.r.wheel <Button-1> {
    scan [ColorWheel get %x %y] "%%f %%f %%f" r g b
    .back.f1.l.r set $r
    .back.f1.l.g set $g
    .back.f1.l.b set $b
}
pack .back.f1.r.wheel -fill both
pack .back.f1.l .back.f1.m .back.f1.r -side left -expand 1 -fill both

frame .back.fb
button .back.fb.apply -text Apply -command ApplyBackground
button .back.fb.cancel -text Cancel -command CloseBackground
pack .back.fb.apply .back.fb.cancel -side left -expand 1 -fill x
pack .back.f1 .back.fb -side top -fill both -expand 1

proc SetBackgroundColor {value} {
    set color [format #%02x%02x%02x [.back.f1.l.r get] [.back.f1.l.g get]\
	    [.back.f1.l.b get]]
    .back.f1.m.sample config -background $color
}

proc ApplyBackground {} {
    global RenWin

    Renderer SetBackground [expr [.back.f1.l.r get]/255.0] \
	    [expr [.back.f1.l.g get]/255.0] \
	    [expr [.back.f1.l.b get]/255.0]
    CompareRenderer SetBackground [expr [.back.f1.l.r get]/255.0] \
	    [expr [.back.f1.l.g get]/255.0] \
	    [expr [.back.f1.l.b get]/255.0]
    $RenWin Render
}

############################ Setting edge color
##
proc EdgeColor {} {

    set color [frontProperty GetEdgeColor]
    .edge.f1.l.r set [expr [lindex $color 0] * 255.0]
    .edge.f1.l.g set [expr [lindex $color 1] * 255.0]
    .edge.f1.l.b set [expr [lindex $color 2] * 255.0]
    wm deiconify .edge
}

proc CloseEdge {} {
    wm withdraw .edge
}

toplevel .edge
wm withdraw .edge
wm title .edge "Set Edge Color"
wm protocol .edge WM_DELETE_WINDOW {wm withdraw .edge}
frame .edge.f1

frame .edge.f1.l  -relief raised -borderwidth 3
scale .edge.f1.l.r -from 255 -to 0 -orient vertical -background #f00 \
	-command SetEdgeColor
scale .edge.f1.l.g -from 255 -to 0 -orient vertical -background #0f0 \
	-command SetEdgeColor
scale .edge.f1.l.b -from 255 -to 0 -orient vertical -background #00f \
	-command SetEdgeColor
pack .edge.f1.l.r .edge.f1.l.g .edge.f1.l.b -side left -fill both

frame .edge.f1.m -relief raised -borderwidth 3
label .edge.f1.m.sample -highlightthickness 0 -text "    Edge Color    "
pack .edge.f1.m.sample -fill both -expand 1

frame .edge.f1.r -relief raised -borderwidth 3
image create photo ColorWheel -file /usr/local/pkgs/vizvtk/lib/ColorWheel.ppm
label .edge.f1.r.wheel -image ColorWheel -highlightthickness 0
bind .edge.f1.r.wheel <Button-1> {
    scan [ColorWheel get %x %y] "%%f %%f %%f" r g b
    .edge.f1.l.r set $r
    .edge.f1.l.g set $g
    .edge.f1.l.b set $b
}
pack .edge.f1.r.wheel -fill both
pack .edge.f1.l .edge.f1.m .edge.f1.r -side left -expand 1 -fill both

frame .edge.f2
checkbutton .edge.f2.cb1 -text "Show Edges" -variable ObjEdges
pack .edge.f2.cb1 -fill both

frame .edge.fb
button .edge.fb.apply -text Apply -command ApplyEdgeColor
button .edge.fb.cancel -text Cancel -command CloseEdge
pack .edge.fb.apply .edge.fb.cancel -side left -expand 1 -fill x
pack .edge.f1 .edge.f2 .edge.fb -side top -fill both -expand 1

proc SetEdgeColor {value} {
    set color [format #%02x%02x%02x [.edge.f1.l.r get] [.edge.f1.l.g get]\
	    [.edge.f1.l.b get]]
    .edge.f1.m.sample config -background $color
}

proc ApplyEdgeColor {} {
    global RenWin
    global ObjEdges

    if { $ObjEdges } {
      frontProperty SetRepresentationToPoints
      frontProperty EdgeVisibilityOn
      backProperty EdgeVisibilityOn
    } else {
      frontProperty SetRepresentationToSurface
      frontProperty EdgeVisibilityOff
      backProperty EdgeVisibilityOff
    }
    frontProperty SetEdgeColor [expr [.edge.f1.l.r get]/255.0] \
	    [expr [.edge.f1.l.g get]/255.0] \
	    [expr [.edge.f1.l.b get]/255.0]
    backProperty SetEdgeColor [expr [.edge.f1.l.r get]/255.0] \
	    [expr [.edge.f1.l.g get]/255.0] \
	    [expr [.edge.f1.l.b get]/255.0]
    $RenWin Render
}

############################ Set front surface properties
##
proc FrontProperties {} {

    set color [frontProperty GetColor]
    .frontprop.f1.l.r set [expr [lindex $color 0] * 255.0]
    .frontprop.f1.l.g set [expr [lindex $color 1] * 255.0]
    .frontprop.f1.l.b set [expr [lindex $color 2] * 255.0]
    .frontprop.sliders.amb set [frontProperty GetAmbient]
    .frontprop.sliders.diff set [frontProperty GetDiffuse]
    .frontprop.sliders.spec set [frontProperty GetSpecular]
    .frontprop.sliders.power set [frontProperty GetSpecularPower]

    wm deiconify .frontprop
}

proc CloseFrontProperties {} {
    wm withdraw .frontprop
}

toplevel .frontprop
wm withdraw .frontprop
wm title .frontprop "Set Front Surface Properties"
wm protocol .frontprop WM_DELETE_WINDOW {wm withdraw .frontprop}
frame .frontprop.f1

frame .frontprop.f1.l  -relief raised -borderwidth 3
scale .frontprop.f1.l.r -from 255 -to 0 -orient vertical -background #f00 \
	-command SetFrontSurfaceColor
scale .frontprop.f1.l.g -from 255 -to 0 -orient vertical -background #0f0 \
	-command SetFrontSurfaceColor
scale .frontprop.f1.l.b -from 255 -to 0 -orient vertical -background #00f \
	-command SetFrontSurfaceColor
pack .frontprop.f1.l.r .frontprop.f1.l.g .frontprop.f1.l.b -side left -fill both

frame .frontprop.f1.m -relief raised -borderwidth 3
label .frontprop.f1.m.sample -highlightthickness 0 -text "   Surface Color    "
pack .frontprop.f1.m.sample -fill both -expand 1

frame .frontprop.f1.r -relief raised -borderwidth 3
image create photo ColorWheel -file /usr/local/pkgs/vizvtk/lib/ColorWheel.ppm
label .frontprop.f1.r.wheel -image ColorWheel -highlightthickness 0
bind .frontprop.f1.r.wheel <Button-1> {
    scan [ColorWheel get %x %y] "%%f %%f %%f" r g b
    .frontprop.f1.l.r set $r
    .frontprop.f1.l.g set $g
    .frontprop.f1.l.b set $b
}
pack .frontprop.f1.r.wheel -fill both
pack .frontprop.f1.l .frontprop.f1.m .frontprop.f1.r -side left -expand 1 -fill both

frame .frontprop.sliders
scale .frontprop.sliders.amb -from 0.00 -to 1.00 -orient horizontal\
	-resolution 0.01 -label Ambient
scale .frontprop.sliders.diff -from 0.00 -to 1.00 -orient horizontal\
	-resolution 0.01 -label Diffuse
scale .frontprop.sliders.spec -from 0.00 -to 1.00 -orient horizontal\
	-resolution 0.01 -label Specular
scale .frontprop.sliders.power -from 0 -to 100 -orient horizontal\
	-resolution 1 -label "Specular Power"
pack .frontprop.sliders.spec .frontprop.sliders.power .frontprop.sliders.amb\
	.frontprop.sliders.diff -side top -fill both

frame .frontprop.fb
button .frontprop.fb.apply -text Apply -command ApplyFrontProperties
button .frontprop.fb.cancel -text Cancel -command CloseFrontProperties
pack .frontprop.fb.apply .frontprop.fb.cancel -side left -expand 1 -fill x
pack .frontprop.f1 .frontprop.sliders .frontprop.fb -side top -fill both -expand 1

proc SetFrontSurfaceColor {value} {
    set color [format #%02x%02x%02x [.frontprop.f1.l.r get] [.frontprop.f1.l.g get]\
	    [.frontprop.f1.l.b get]]
    .frontprop.f1.m.sample config -background $color
}

proc ApplyFrontProperties {} {
    global RenWin

    frontProperty SetColor [expr [.frontprop.f1.l.r get]/255.0] \
	    [expr [.frontprop.f1.l.g get]/255.0] \
	    [expr [.frontprop.f1.l.b get]/255.0]
    frontProperty SetAmbient [.frontprop.sliders.amb get]
    frontProperty SetDiffuse [.frontprop.sliders.diff get]
    frontProperty SetSpecular [.frontprop.sliders.spec get]
    frontProperty SetSpecularPower [.frontprop.sliders.power get]
    $RenWin Render
}

############################ Set back surface properties
##
proc BackProperties {} {

    set color [backProperty GetColor]
    .backprop.f1.l.r set [expr [lindex $color 0] * 255.0]
    .backprop.f1.l.g set [expr [lindex $color 1] * 255.0]
    .backprop.f1.l.b set [expr [lindex $color 2] * 255.0]
    .backprop.sliders.amb set [backProperty GetAmbient]
    .backprop.sliders.diff set [backProperty GetDiffuse]
    .backprop.sliders.spec set [backProperty GetSpecular]
    .backprop.sliders.power set [backProperty GetSpecularPower]

    wm deiconify .backprop
}

proc CloseBackProperties {} {
    wm withdraw .backprop
}

toplevel .backprop
wm withdraw .backprop
wm title .backprop "Set Back Surface Properties"
wm protocol .backprop WM_DELETE_WINDOW {wm withdraw .backprop}
frame .backprop.f1

frame .backprop.f1.l  -relief raised -borderwidth 3
scale .backprop.f1.l.r -from 255 -to 0 -orient vertical -background #f00 \
	-command SetBackSurfaceColor
scale .backprop.f1.l.g -from 255 -to 0 -orient vertical -background #0f0 \
	-command SetBackSurfaceColor
scale .backprop.f1.l.b -from 255 -to 0 -orient vertical -background #00f \
	-command SetBackSurfaceColor
pack .backprop.f1.l.r .backprop.f1.l.g .backprop.f1.l.b -side left -fill both

frame .backprop.f1.m -relief raised -borderwidth 3
label .backprop.f1.m.sample -highlightthickness 0 -text "   Surface Color    "
pack .backprop.f1.m.sample -fill both -expand 1

frame .backprop.f1.r -relief raised -borderwidth 3
image create photo ColorWheel -file /usr/local/pkgs/vizvtk/lib/ColorWheel.ppm
label .backprop.f1.r.wheel -image ColorWheel -highlightthickness 0
bind .backprop.f1.r.wheel <Button-1> {
    scan [ColorWheel get %x %y] "%%f %%f %%f" r g b
    .backprop.f1.l.r set $r
    .backprop.f1.l.g set $g
    .backprop.f1.l.b set $b
}
pack .backprop.f1.r.wheel -fill both
pack .backprop.f1.l .backprop.f1.m .backprop.f1.r -side left -expand 1 -fill both

frame .backprop.sliders
scale .backprop.sliders.amb -from 0.00 -to 1.00 -orient horizontal\
	-resolution 0.01 -label Ambient
scale .backprop.sliders.diff -from 0.00 -to 1.00 -orient horizontal\
	-resolution 0.01 -label Diffuse
scale .backprop.sliders.spec -from 0.00 -to 1.00 -orient horizontal\
	-resolution 0.01 -label Specular
scale .backprop.sliders.power -from 0 -to 100 -orient horizontal\
	-resolution 1 -label "Specular Power"
pack .backprop.sliders.spec .backprop.sliders.power .backprop.sliders.amb\
	.backprop.sliders.diff -side top -fill both

frame .backprop.fb
button .backprop.fb.apply -text Apply -command ApplyBackProperties
button .backprop.fb.cancel -text Cancel -command CloseBackProperties
pack .backprop.fb.apply .backprop.fb.cancel -side left -expand 1 -fill x
pack .backprop.f1 .backprop.sliders .backprop.fb -side top -fill both -expand 1

proc SetBackSurfaceColor {value} {
    set color [format #%02x%02x%02x [.backprop.f1.l.r get] [.backprop.f1.l.g get]\
	    [.backprop.f1.l.b get]]
    .backprop.f1.m.sample config -background $color
}

proc ApplyBackProperties {} {
    global RenWin

    backProperty SetColor [expr [.backprop.f1.l.r get]/255.0] \
	    [expr [.backprop.f1.l.g get]/255.0] \
	    [expr [.backprop.f1.l.b get]/255.0]
    backProperty SetAmbient [.backprop.sliders.amb get]
    backProperty SetDiffuse [.backprop.sliders.diff get]
    backProperty SetSpecular [.backprop.sliders.spec get]
    backProperty SetSpecularPower [.backprop.sliders.power get]
    $RenWin Render
}

#
#------------------------Procedures for ProgressWidget----------------------
#
proc StartProgress {filter label} {
   global BarId
   global TextId

   set height [winfo height .bottomF.status]
   set width [winfo width .bottomF.status]

   if { ![winfo exists .bottomF.canvas] } {
      canvas .bottomF.canvas -height $height -width $width -borderwidth 0\
	    -highlightthickness 0
   } else {
      .bottomF.canvas configure -height $height -width $width
      .bottomF.canvas delete $BarId
      .bottomF.canvas delete $TextId
   }

   set BarId [.bottomF.canvas create rect 0 0 0 $height -fill #888]
   set TextId [.bottomF.canvas create text [expr $width/2] [expr $height/2] \
	   -anchor center -justify center -text $label]
   pack forget .bottomF.status
   pack .bottomF.canvas -padx 0 -pady 0

   update
}

proc ShowProgress {filter label} {
   global BarId
   global TextId

   set progress [$filter GetProgress]

   if { [expr {int($progress*100)%10}] == 0 } {
     set height [winfo height .bottomF.status]
     set width [winfo width .bottomF.status]

     .bottomF.canvas delete $BarId
     .bottomF.canvas delete $TextId
     set BarId [.bottomF.canvas create rect 0 0 [expr {$progress*$width}] \
             $height -fill #888]
     set TextId [.bottomF.canvas create text \
             [expr {$width/2}] [expr {$height/2}] \
	     -anchor center -justify center -text $label]
  
     update
   }
}

proc EndProgress {} {
   pack forget .bottomF.canvas
   pack .bottomF.status -side top -anchor w -expand 1 -fill x

   update
}

