<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>meshmorph: state.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>state.cc</h1><a href="state_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include "<a class="code" href="state_8h.html">state.h</a>"</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="box_8h.html">box.h</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="container_8h.html">container.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="edge_8h.html">edge.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="face_8h.html">face.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="gain__schedule_8h.html">gain_schedule.h</a>"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="intersecting__faces_8h.html">intersecting_faces.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "<a class="code" href="space_8h.html">space.h</a>"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="vertex_8h.html">vertex.h</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="virtual__disp_8h.html">virtual_disp.h</a>"</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">using</span> std::cout;
<a name="l00017"></a>00017 <span class="keyword">using</span> std::endl;
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <a class="code" href="classState.html">State</a> * State::only_one = NULL;
<a name="l00020"></a>00020 
<a name="l00021"></a><a class="code" href="classState.html#cd3aa3488c0124d7d4774ff0f7250685">00021</a> <a class="code" href="classState.html">State</a> &amp; <a class="code" href="classState.html#cd3aa3488c0124d7d4774ff0f7250685">State::instance</a>(<span class="keywordtype">void</span>)
<a name="l00022"></a>00022 {
<a name="l00023"></a>00023   <span class="comment">// Not thread-safe.</span>
<a name="l00024"></a>00024   <span class="comment">// -- lock mutex</span>
<a name="l00025"></a>00025   <span class="keywordflow">if</span> (only_one == NULL)
<a name="l00026"></a>00026     only_one = <span class="keyword">new</span> <a class="code" href="classState.html">State</a>();
<a name="l00027"></a>00027   <span class="comment">// -- unlock mutex</span>
<a name="l00028"></a>00028   <span class="keywordflow">return</span> *only_one;
<a name="l00029"></a>00029 }
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 State::State (<span class="keyword">const</span> <a class="code" href="classState.html">State</a>&amp; rhs)
<a name="l00032"></a>00032   :nb(),
<a name="l00033"></a>00033   ae(),ea(),vd2(0)
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035   cout &lt;&lt; <span class="stringliteral">"Assignment operator prohibited on instances of State class.\n"</span>;
<a name="l00036"></a>00036   cout &lt;&lt; <span class="stringliteral">"State "</span> &lt;&lt; rhs.<a class="code" href="classState.html#3d8ad482930c3fe13e1c241cf4865db6">nb</a>.size()&lt;&lt; endl;
<a name="l00037"></a>00037   exit(0);
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 State::State (<span class="keywordtype">void</span>)
<a name="l00041"></a>00041   :nb(),
<a name="l00042"></a>00042   ae(),ea(),vd2(0)
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044   ae.reserve(VECTOR_RESERVE);
<a name="l00045"></a>00045 };
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <a class="code" href="classState.html">State</a>&amp; State::operator= (<span class="keyword">const</span> <a class="code" href="classState.html">State</a>&amp; rhs)
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049   cout &lt;&lt; <span class="stringliteral">"Copy assignment operator prohibited on instances of State class.\n"</span>;
<a name="l00050"></a>00050   cout &lt;&lt; <span class="stringliteral">"State "</span> &lt;&lt; rhs.<a class="code" href="classState.html#3d8ad482930c3fe13e1c241cf4865db6">nb</a>.size() &lt;&lt; endl;
<a name="l00051"></a>00051   exit(0);
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="classState.html#764ce2e15b97118a2b621bd5b379426a">00054</a> <span class="keywordtype">double</span> <a class="code" href="classState.html#764ce2e15b97118a2b621bd5b379426a">State::getVD2</a> (<span class="keywordtype">void</span>)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <span class="keywordflow">return</span> vd2;
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="classState.html#b146b741af342f972dc4d0d22d37c063">00059</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#b146b741af342f972dc4d0d22d37c063">State::setVD2</a> (<span class="keywordtype">double</span> d)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061   vd2 = d;
<a name="l00062"></a>00062 }
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">//void State::addVertexToSetNiceCheck (Vertex * v)</span>
<a name="l00065"></a>00065 <span class="comment">//{</span>
<a name="l00066"></a>00066 <span class="comment">//  ni.insert(const_cast&lt;Vertex*&gt;(v));</span>
<a name="l00067"></a>00067 <span class="comment">//}</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">//void State::addVertexToFullSearch (Vertex * v)</span>
<a name="l00070"></a>00070 <span class="comment">//{</span>
<a name="l00071"></a>00071 <span class="comment">//  fs.insert(v);</span>
<a name="l00072"></a>00072 <span class="comment">//}</span>
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="classState.html#0a7a4a8734109f6bebf3517226e52ca3">00074</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#0a7a4a8734109f6bebf3517226e52ca3">State::clearNewFaces</a> (<span class="keywordtype">void</span>)
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076   nb.clear();
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">//void State::clearSetNiceCheck (void)</span>
<a name="l00080"></a>00080 <span class="comment">//{</span>
<a name="l00081"></a>00081 <span class="comment">//  ni.clear();</span>
<a name="l00082"></a>00082 <span class="comment">//}</span>
<a name="l00083"></a>00083 
<a name="l00084"></a><a class="code" href="classState.html#73fe266dcbb27bc9cac8cec4ab060ea8">00084</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#73fe266dcbb27bc9cac8cec4ab060ea8">State::addNewFace</a> (<a class="code" href="classFace.html">Face</a> * <span class="keyword">const</span> f,<a class="code" href="classBox.html">Box</a> * <span class="keyword">const</span> b)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086   nb.insert(std::make_pair(f,b));
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">//hv_it State::ni_begin (void)</span>
<a name="l00090"></a>00090 <span class="comment">//{</span>
<a name="l00091"></a>00091 <span class="comment">//  return ni.begin();</span>
<a name="l00092"></a>00092 <span class="comment">//}</span>
<a name="l00093"></a>00093 <span class="comment">//</span>
<a name="l00094"></a>00094 <span class="comment">//hv_it State::ni_end (void)</span>
<a name="l00095"></a>00095 <span class="comment">//{</span>
<a name="l00096"></a>00096 <span class="comment">//  return ni.end();</span>
<a name="l00097"></a>00097 <span class="comment">//}</span>
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="classState.html#5a6de40ee1c1a4926ed2c0a991845582">00099</a> <a class="code" href="meshmorph_8h.html#87faf2ec676ddb99351498b29fb1a6b4">mmap_fp_bp</a> <a class="code" href="classState.html#5a6de40ee1c1a4926ed2c0a991845582">State::getOrigBoxesOfVertAdjFaces</a> (<a class="code" href="classVertex.html">Vertex</a> * <span class="keyword">const</span> v)
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101   <a class="code" href="meshmorph_8h.html#58cf62c0a16eae244b83de08e6cb1ad7">vec_bp</a> vbp;
<a name="l00102"></a>00102   <span class="comment">//ob.clear();</span>
<a name="l00103"></a>00103   <a class="code" href="meshmorph_8h.html#87faf2ec676ddb99351498b29fb1a6b4">mmap_fp_bp</a> ob;
<a name="l00104"></a>00104   <span class="comment">// for each adjacent face</span>
<a name="l00105"></a>00105   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();i!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();i++)
<a name="l00106"></a>00106   {
<a name="l00107"></a>00107     <span class="comment">// get boxes that overlap this face's bounding box</span>
<a name="l00108"></a>00108     vbp.clear();
<a name="l00109"></a>00109     <a class="code" href="classSpace.html#c0c2e1be07b8a675445b46f575d22a87">Space::instance</a>().<a class="code" href="classSpace.html#dfc42f0706f2d44d88f322d78488ca08">getBoxesToCheck</a>(*i,vbp);
<a name="l00110"></a>00110     <span class="comment">// add box*s to multimap ob</span>
<a name="l00111"></a>00111     <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#dbed886c1b2567fd85a7cbfd42af88e3">bp_it</a> j=vbp.begin();j!=vbp.end();j++)
<a name="l00112"></a>00112     {
<a name="l00113"></a>00113       ob.insert(std::make_pair(*i,*j));
<a name="l00114"></a>00114     }
<a name="l00115"></a>00115   }
<a name="l00116"></a>00116   <span class="keywordflow">return</span> ob;
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 
<a name="l00126"></a><a class="code" href="classState.html#8735800613feb7b4fa430344bfef6ee8">00126</a> <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> <a class="code" href="classState.html#8735800613feb7b4fa430344bfef6ee8">State::getVertsForFullClosestPtSearch</a> (<a class="code" href="classVertex.html">Vertex</a> <span class="keyword">const</span> * <span class="keyword">const</span> v)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128   <span class="keywordtype">double</span> bb[6];
<a name="l00129"></a>00129   v-&gt;<a class="code" href="classVertex.html#5bba0714f468b8f7baf414de12cf344a">getBoundingBox</a>(bb);
<a name="l00130"></a>00130   <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> origin(3,0),end(3,0);
<a name="l00131"></a>00131   origin[0] = bb[0]-(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00132"></a>00132   origin[1] = bb[2]-(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00133"></a>00133   origin[2] = bb[4]-(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00134"></a>00134   end[0]    = bb[1]+(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00135"></a>00135   end[1]    = bb[3]+(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00136"></a>00136   end[2]    = bb[5]+(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00137"></a>00137   <a class="code" href="meshmorph_8h.html#58cf62c0a16eae244b83de08e6cb1ad7">vec_bp</a> bp;
<a name="l00138"></a>00138   <a class="code" href="classSpace.html#c0c2e1be07b8a675445b46f575d22a87">Space::instance</a>().<a class="code" href="classSpace.html#b62bb8415270032b864f95c498830575">getBoxesFromPosition</a>(origin,end,bp);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> fs;
<a name="l00141"></a>00141   fs.reserve(<a class="code" href="controls_8h.html#526dd339829f063fe1f5b9219792e7be">VECTOR_RESERVE</a>);
<a name="l00142"></a>00142   <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> t;
<a name="l00143"></a>00143   t.reserve(<a class="code" href="controls_8h.html#526dd339829f063fe1f5b9219792e7be">VECTOR_RESERVE</a>);
<a name="l00144"></a>00144   <span class="comment">// for each box</span>
<a name="l00145"></a>00145   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#dbed886c1b2567fd85a7cbfd42af88e3">bp_it</a> i=bp.begin();i!=bp.end();i++)
<a name="l00146"></a>00146   {
<a name="l00147"></a>00147     <span class="comment">// for each face in box</span>
<a name="l00148"></a>00148     <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> j=(*i)-&gt;begin();j!=(*i)-&gt;end();j++)
<a name="l00149"></a>00149     {
<a name="l00150"></a>00150       <span class="comment">// add face vertices to vector</span>
<a name="l00151"></a>00151       t.push_back((*j)-&gt;getVertex(0));
<a name="l00152"></a>00152       t.push_back((*j)-&gt;getVertex(1));
<a name="l00153"></a>00153       t.push_back((*j)-&gt;getVertex(2));
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155   }
<a name="l00156"></a>00156   <span class="comment">// sort and keep unique vertices</span>
<a name="l00157"></a>00157   sort(t.begin(),t.end());
<a name="l00158"></a>00158   t.assign(t.begin(),unique(t.begin(),t.end()));
<a name="l00159"></a>00159   <span class="comment">// for each vertex in vector</span>
<a name="l00160"></a>00160   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#739e6a4d59cef4b66aa367b884b12cb7">vp_it</a> j=t.begin();j!=t.end();j++)
<a name="l00161"></a>00161   {
<a name="l00162"></a>00162     <span class="comment">// if face vertex is not frozen, has a closest point and</span>
<a name="l00163"></a>00163     <span class="comment">// closest point lies on an adjacent face of active vertex, v</span>
<a name="l00164"></a>00164     <span class="comment">// then add vertex to affected vertex set</span>
<a name="l00165"></a>00165     <span class="keywordflow">if</span>( (<a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().vertexIsFrozen(*j)==<span class="keyword">false</span>)
<a name="l00166"></a>00166         &amp;&amp; (*j)-&gt;getFace()!=NULL &amp;&amp; binary_search(v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>(),v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>(),(*j)-&gt;getFace()) )
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168       fs.push_back(*j);
<a name="l00169"></a>00169     }
<a name="l00170"></a>00170   }
<a name="l00171"></a>00171   <span class="comment">// adjacent vertices to current vertex need full search for closest point</span>
<a name="l00172"></a>00172   <span class="comment">// since vertx normal will have changed</span>
<a name="l00173"></a>00173   t.clear();
<a name="l00174"></a>00174   <span class="comment">// for each face in box</span>
<a name="l00175"></a>00175   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> k=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();k!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();k++)
<a name="l00176"></a>00176   {
<a name="l00177"></a>00177     <span class="comment">// add face vertices to vector</span>
<a name="l00178"></a>00178     t.push_back((*k)-&gt;getVertex(0));
<a name="l00179"></a>00179     t.push_back((*k)-&gt;getVertex(1));
<a name="l00180"></a>00180     t.push_back((*k)-&gt;getVertex(2));
<a name="l00181"></a>00181   }
<a name="l00182"></a>00182   <span class="comment">// sort and keep unique vertices</span>
<a name="l00183"></a>00183   sort(t.begin(),t.end());
<a name="l00184"></a>00184   t.assign(t.begin(),unique(t.begin(),t.end()));
<a name="l00185"></a>00185   <span class="comment">// for each vertex in vector</span>
<a name="l00186"></a>00186   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#739e6a4d59cef4b66aa367b884b12cb7">vp_it</a> j=t.begin();j!=t.end();j++)
<a name="l00187"></a>00187   {
<a name="l00188"></a>00188     <span class="comment">// if face vertex is not frozen</span>
<a name="l00189"></a>00189     <span class="comment">// then add vertex to affected vertex set</span>
<a name="l00190"></a>00190     <span class="keywordflow">if</span>( (<a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().vertexIsFrozen(*j)==<span class="keyword">false</span>) )
<a name="l00191"></a>00191     {
<a name="l00192"></a>00192       fs.push_back(*j);
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194   }
<a name="l00195"></a>00195   <span class="keywordflow">return</span> fs;
<a name="l00196"></a>00196 }
<a name="l00197"></a>00197 
<a name="l00205"></a><a class="code" href="classState.html#b8df6ba93c188015d8951e130f89bcdc">00205</a> <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> <a class="code" href="classState.html#b8df6ba93c188015d8951e130f89bcdc">State::getVertsForPartialClosestPtSearch</a> (<a class="code" href="classVertex.html">Vertex</a> <span class="keyword">const</span> * <span class="keyword">const</span> v)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207   <span class="keywordtype">double</span> bb[6];
<a name="l00208"></a>00208   v-&gt;<a class="code" href="classVertex.html#5bba0714f468b8f7baf414de12cf344a">getBoundingBox</a>(bb);
<a name="l00209"></a>00209   <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> origin(3,0),end(3,0);
<a name="l00210"></a>00210   origin[0] = bb[0]-(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00211"></a>00211   origin[1] = bb[2]-(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00212"></a>00212   origin[2] = bb[4]-(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00213"></a>00213   end[0]    = bb[1]+(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00214"></a>00214   end[1]    = bb[3]+(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00215"></a>00215   end[2]    = bb[5]+(<a class="code" href="controls_8h.html#50f8a7348edaf08b82d912aa0a9e7e9f">NUM_ADJACENT_BOXES</a>*<a class="code" href="controls_8h.html#8375b2e8e569b439b084b69637e001e5">SPACE_LENGTH</a>)*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00216"></a>00216   <a class="code" href="meshmorph_8h.html#58cf62c0a16eae244b83de08e6cb1ad7">vec_bp</a> bp;
<a name="l00217"></a>00217   <a class="code" href="classSpace.html#c0c2e1be07b8a675445b46f575d22a87">Space::instance</a>().<a class="code" href="classSpace.html#b62bb8415270032b864f95c498830575">getBoxesFromPosition</a>(origin,end,bp);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> ps;
<a name="l00220"></a>00220   ps.reserve(<a class="code" href="controls_8h.html#526dd339829f063fe1f5b9219792e7be">VECTOR_RESERVE</a>);
<a name="l00221"></a>00221   <span class="comment">// for each box</span>
<a name="l00222"></a>00222   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#dbed886c1b2567fd85a7cbfd42af88e3">bp_it</a> i=bp.begin();i!=bp.end();i++)
<a name="l00223"></a>00223   {
<a name="l00224"></a>00224     <span class="comment">// for each face in box</span>
<a name="l00225"></a>00225     <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> j=(*i)-&gt;begin();j!=(*i)-&gt;end();j++)
<a name="l00226"></a>00226     {
<a name="l00227"></a>00227       <span class="comment">// for each vertex of face</span>
<a name="l00228"></a>00228       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;3;k++)
<a name="l00229"></a>00229       {
<a name="l00230"></a>00230         <span class="comment">// store face vertices</span>
<a name="l00231"></a>00231         ps.push_back((*j)-&gt;getVertex(k));
<a name="l00232"></a>00232       }
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234   }
<a name="l00235"></a>00235   <span class="comment">// sort and keep unique </span>
<a name="l00236"></a>00236   sort(ps.begin(),ps.end());
<a name="l00237"></a>00237   ps.assign(ps.begin(),unique(ps.begin(),ps.end()));
<a name="l00238"></a>00238   <span class="comment">// DEBUG</span>
<a name="l00239"></a>00239 <span class="comment">//  cout &lt;&lt; "State::getVertsForPartialClosestPtSearch:\n"</span>
<a name="l00240"></a>00240 <span class="comment">//       &lt;&lt; "vertex bounding box ["</span>
<a name="l00241"></a>00241 <span class="comment">//       &lt;&lt; bb[0] &lt;&lt; " "</span>
<a name="l00242"></a>00242 <span class="comment">//       &lt;&lt; bb[1] &lt;&lt; " "</span>
<a name="l00243"></a>00243 <span class="comment">//       &lt;&lt; bb[2] &lt;&lt; " "</span>
<a name="l00244"></a>00244 <span class="comment">//       &lt;&lt; bb[3] &lt;&lt; " "</span>
<a name="l00245"></a>00245 <span class="comment">//       &lt;&lt; bb[4] &lt;&lt; " "</span>
<a name="l00246"></a>00246 <span class="comment">//       &lt;&lt; bb[5] &lt;&lt; "]\n"</span>
<a name="l00247"></a>00247 <span class="comment">//       &lt;&lt; "grab boxes from this region ["</span>
<a name="l00248"></a>00248 <span class="comment">//       &lt;&lt; origin[0] &lt;&lt; " "</span>
<a name="l00249"></a>00249 <span class="comment">//       &lt;&lt; end[0]    &lt;&lt; " "</span>
<a name="l00250"></a>00250 <span class="comment">//       &lt;&lt; origin[1] &lt;&lt; " "</span>
<a name="l00251"></a>00251 <span class="comment">//       &lt;&lt; end[1]    &lt;&lt; " "</span>
<a name="l00252"></a>00252 <span class="comment">//       &lt;&lt; origin[2] &lt;&lt; " "</span>
<a name="l00253"></a>00253 <span class="comment">//       &lt;&lt; end[2]    &lt;&lt; "]\n"</span>
<a name="l00254"></a>00254 <span class="comment">//       &lt;&lt; "num vertices in partial search = " &lt;&lt; ps.size() &lt;&lt; endl;</span>
<a name="l00255"></a>00255   <span class="comment">// DEBUG</span>
<a name="l00256"></a>00256   <span class="keywordflow">return</span> ps;
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00259"></a><a class="code" href="classState.html#084f05cd6f8edc9416b864a0e5511ffb">00259</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#084f05cd6f8edc9416b864a0e5511ffb">State::collectEdgeAngles</a> (<a class="code" href="classVertex.html">Vertex</a> <span class="keyword">const</span> * <span class="keyword">const</span> v)
<a name="l00260"></a>00260 {
<a name="l00261"></a>00261   ea.clear();
<a name="l00263"></a>00263   <span class="comment">// for each adjacent face of current vertex</span>
<a name="l00264"></a>00264   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();i!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();i++)
<a name="l00265"></a>00265   {
<a name="l00266"></a>00266     ea[(*i)-&gt;getEdge(0)] = (*i)-&gt;getEdge(0)-&gt;getAngle();
<a name="l00267"></a>00267     ea[(*i)-&gt;getEdge(1)] = (*i)-&gt;getEdge(1)-&gt;getAngle();
<a name="l00268"></a>00268     ea[(*i)-&gt;getEdge(2)] = (*i)-&gt;getEdge(2)-&gt;getAngle();
<a name="l00269"></a>00269   }
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00280"></a><a class="code" href="classState.html#0215b7e7094ff53afd64e460547010ca">00280</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#0215b7e7094ff53afd64e460547010ca">State::updateClosestFaceToVertices</a> (<a class="code" href="classVertex.html">Vertex</a> * <span class="keyword">const</span> v,<a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> &amp; fs,<a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> &amp; ps)
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282   <span class="keywordtype">double</span> dummy[3] = {0.0,0.0,0.0};
<a name="l00283"></a>00283   <span class="comment">// sort and keep unique </span>
<a name="l00284"></a>00284   sort(fs.begin(),fs.end());
<a name="l00285"></a>00285   fs.assign(fs.begin(),unique(fs.begin(),fs.end()));
<a name="l00286"></a>00286   <span class="comment">// DEBUG</span>
<a name="l00287"></a>00287   <span class="comment">//bool found = false;</span>
<a name="l00288"></a>00288   <span class="comment">//for(vp_it i=fs.begin();i!=fs.end();i++)</span>
<a name="l00289"></a>00289   <span class="comment">//{</span>
<a name="l00290"></a>00290   <span class="comment">//  if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true) found=true;</span>
<a name="l00291"></a>00291   <span class="comment">//}</span>
<a name="l00292"></a>00292   <span class="comment">//if(found==true)</span>
<a name="l00293"></a>00293   <span class="comment">//{</span>
<a name="l00294"></a>00294   <span class="comment">//  cout &lt;&lt; "\n\n\ntarget vertex found in full_search vector.\n";</span>
<a name="l00295"></a>00295   <span class="comment">//}</span>
<a name="l00296"></a>00296   <span class="comment">//else</span>
<a name="l00297"></a>00297   <span class="comment">//{</span>
<a name="l00298"></a>00298   <span class="comment">//  cout &lt;&lt; "\n\n\ntarget vertex NOT found in full_search vector.\n";</span>
<a name="l00299"></a>00299   <span class="comment">//}</span>
<a name="l00300"></a>00300   <span class="comment">//found = false;</span>
<a name="l00301"></a>00301   <span class="comment">//for(vp_it i=ps.begin();i!=ps.end();i++)</span>
<a name="l00302"></a>00302   <span class="comment">//{</span>
<a name="l00303"></a>00303   <span class="comment">//  if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true) found=true;</span>
<a name="l00304"></a>00304   <span class="comment">//}</span>
<a name="l00305"></a>00305   <span class="comment">//if(found==true)</span>
<a name="l00306"></a>00306   <span class="comment">//{</span>
<a name="l00307"></a>00307   <span class="comment">//  cout &lt;&lt; "target vertex found in partial_search vector.\n";</span>
<a name="l00308"></a>00308   <span class="comment">//}</span>
<a name="l00309"></a>00309   <span class="comment">//else</span>
<a name="l00310"></a>00310   <span class="comment">//{</span>
<a name="l00311"></a>00311   <span class="comment">//  cout &lt;&lt; "target vertex NOT found in partial_search vector.\n";</span>
<a name="l00312"></a>00312   <span class="comment">//}</span>
<a name="l00313"></a>00313   <span class="comment">// DEBUG</span>
<a name="l00314"></a>00314   <span class="comment">// for each collected vertex requiring full closest point search</span>
<a name="l00315"></a>00315   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#739e6a4d59cef4b66aa367b884b12cb7">vp_it</a> i=fs.begin();i!=fs.end();i++)
<a name="l00316"></a>00316   {
<a name="l00317"></a>00317     <span class="comment">// if vertex is not frozen</span>
<a name="l00318"></a>00318     <span class="keywordflow">if</span>(<a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().vertexIsFrozen(*i)==<span class="keyword">false</span>)
<a name="l00319"></a>00319     {
<a name="l00320"></a>00320       <span class="comment">// DEBUG</span>
<a name="l00321"></a>00321       <span class="comment">//if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true)</span>
<a name="l00322"></a>00322       <span class="comment">//{</span>
<a name="l00323"></a>00323       <span class="comment">//  cout &lt;&lt; "\ntarget vertex will be processed as full_search.\n";</span>
<a name="l00324"></a>00324       <span class="comment">//  if((*i)-&gt;getFace()==NULL)</span>
<a name="l00325"></a>00325       <span class="comment">//  {</span>
<a name="l00326"></a>00326       <span class="comment">//    cout &lt;&lt; "target vertex closest face started as NULL.\n";</span>
<a name="l00327"></a>00327       <span class="comment">//  }</span>
<a name="l00328"></a>00328       <span class="comment">//  else</span>
<a name="l00329"></a>00329       <span class="comment">//  {</span>
<a name="l00330"></a>00330       <span class="comment">//    cout &lt;&lt; "target vertex closest face started as follows.\n";</span>
<a name="l00331"></a>00331       <span class="comment">//    (*i)-&gt;getFace()-&gt;print(cout);</span>
<a name="l00332"></a>00332       <span class="comment">//  }</span>
<a name="l00333"></a>00333       <span class="comment">//}</span>
<a name="l00334"></a>00334       <span class="comment">// DEBUG</span>
<a name="l00335"></a>00335       <a class="code" href="classFace.html">Face</a> *cl=NULL;
<a name="l00336"></a>00336       <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> p;
<a name="l00337"></a>00337       <span class="keywordtype">double</span> sqd=0.0;
<a name="l00338"></a>00338       <span class="keywordtype">bool</span> flag = <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#a6de2cb8a28ef6191895755655de14e7">findClosestPtToVertex</a>(*i,p,sqd,cl);
<a name="l00339"></a>00339       <span class="keywordflow">if</span> (flag==<span class="keyword">true</span>)
<a name="l00340"></a>00340       {
<a name="l00341"></a>00341         (*i)-&gt;setFace(cl);
<a name="l00342"></a>00342       }
<a name="l00343"></a>00343       <span class="keywordflow">else</span>
<a name="l00344"></a>00344       {
<a name="l00345"></a>00345         (*i)-&gt;setFace(NULL);
<a name="l00346"></a>00346       }
<a name="l00347"></a>00347       <span class="comment">// DEBUG</span>
<a name="l00348"></a>00348       <span class="comment">//if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true)</span>
<a name="l00349"></a>00349       <span class="comment">//{</span>
<a name="l00350"></a>00350       <span class="comment">//  if(flag==true)</span>
<a name="l00351"></a>00351       <span class="comment">//  {</span>
<a name="l00352"></a>00352       <span class="comment">//    cout &lt;&lt; "closest point wad found on following face.\n";</span>
<a name="l00353"></a>00353       <span class="comment">//    cout &lt;&lt; "separation distance = " &lt;&lt; sqrt(sqd) &lt;&lt; ".\n";</span>
<a name="l00354"></a>00354       <span class="comment">//    cl-&gt;print(cout);</span>
<a name="l00355"></a>00355       <span class="comment">//  }</span>
<a name="l00356"></a>00356       <span class="comment">//  else</span>
<a name="l00357"></a>00357       <span class="comment">//  {</span>
<a name="l00358"></a>00358       <span class="comment">//    cout &lt;&lt; "closest point was NOT found.\n";</span>
<a name="l00359"></a>00359       <span class="comment">//  }</span>
<a name="l00360"></a>00360       <span class="comment">//}</span>
<a name="l00361"></a>00361       <span class="comment">// DEBUG</span>
<a name="l00362"></a>00362       <a class="code" href="classVirtual__Disp.html#cfa60cce91fdade84b2030b81d70ad22">Virtual_Disp::instance</a>().<a class="code" href="classVirtual__Disp.html#f84a46a54b0dacde41dfee031405537a">updateVirtualDisp</a>(*i,flag);
<a name="l00363"></a>00363       <span class="comment">// update global energy</span>
<a name="l00364"></a>00364       <span class="comment">// false -&gt; do not compute force, hence dummy</span>
<a name="l00365"></a>00365       <span class="keywordtype">double</span> e=(*i)-&gt;getSeparationForceEnergy(dummy,<span class="keyword">false</span>);
<a name="l00366"></a>00366       <span class="comment">//energy=energy-(*i)-&gt;getEnergy()+e;</span>
<a name="l00367"></a>00367       <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(-(*i)-&gt;getEnergy());
<a name="l00368"></a>00368       <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(e);
<a name="l00369"></a>00369       (*i)-&gt;setEnergy(e);
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371   }
<a name="l00372"></a>00372   <span class="comment">// for each collected vertex not requiring full search</span>
<a name="l00373"></a>00373   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#739e6a4d59cef4b66aa367b884b12cb7">vp_it</a> i=ps.begin();i!=ps.end();i++)
<a name="l00374"></a>00374   {
<a name="l00375"></a>00375     <span class="comment">// if vertex not already processed, i.e. found in fs hashset and not frozen</span>
<a name="l00376"></a>00376     <span class="keywordflow">if</span>((binary_search(fs.begin(),fs.end(),*i)==<span class="keyword">false</span>) &amp;&amp; 
<a name="l00377"></a>00377        (<a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#3c92a60d35c886a638142e654eee99c8">vertexIsFrozen</a>(*i)==<span class="keyword">false</span>))
<a name="l00378"></a>00378     {
<a name="l00381"></a>00381       <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> norm = (*i)-&gt;getNormal();
<a name="l00382"></a>00382       <span class="keywordtype">bool</span> gate=<span class="keyword">false</span>;
<a name="l00383"></a>00383       <span class="keywordtype">double</span> squareD = 0.0;
<a name="l00384"></a>00384       <span class="comment">// compute current square of separation distance for collected vertex</span>
<a name="l00385"></a>00385       <span class="keywordflow">if</span>((*i)-&gt;getFace()!=NULL){ squareD = (*i)-&gt;getSqSepDist(); }
<a name="l00386"></a>00386       <a class="code" href="meshmorph_8h.html#1f34905de522641c355a51fe9e3f1149">vec_fp</a> cf;
<a name="l00387"></a>00387       cf.clear();
<a name="l00388"></a>00388       <span class="comment">// for each adjacent face of vertex *v</span>
<a name="l00389"></a>00389       <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> j=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();j!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();j++)
<a name="l00390"></a>00390       {
<a name="l00391"></a>00391         <span class="comment">// if face is not adjacent to collected vertex, *i</span>
<a name="l00392"></a>00392         <span class="keywordflow">if</span> ((*i)-&gt;faceIsAdjacent(*j)==<span class="keyword">false</span>)
<a name="l00393"></a>00393         {
<a name="l00394"></a>00394           cf.push_back(*j);
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396       }
<a name="l00397"></a>00397       <span class="comment">// DEBUG</span>
<a name="l00398"></a>00398       <span class="comment">//if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true)</span>
<a name="l00399"></a>00399       <span class="comment">//{</span>
<a name="l00400"></a>00400       <span class="comment">//  cout &lt;&lt; "target vertex was processed as partial_search.\n"</span>
<a name="l00401"></a>00401       <span class="comment">//        &lt;&lt; "beginning separation distance = " &lt;&lt; sqrt(squareD) &lt;&lt; endl</span>
<a name="l00402"></a>00402       <span class="comment">//        &lt;&lt; "number of faces searched = " &lt;&lt; cf.size() &lt;&lt; endl;</span>
<a name="l00403"></a>00403       <span class="comment">//  cout &lt;&lt; "********** faces searched **********\n";</span>
<a name="l00404"></a>00404       <span class="comment">//  for (fp_it j=cf.begin();j!=cf.end();j++)</span>
<a name="l00405"></a>00405       <span class="comment">//  {</span>
<a name="l00406"></a>00406       <span class="comment">//    (*j)-&gt;print(cout);</span>
<a name="l00407"></a>00407       <span class="comment">//  }</span>
<a name="l00408"></a>00408       <span class="comment">//  cout &lt;&lt; "********** faces searched **********\n";</span>
<a name="l00409"></a>00409       <span class="comment">//  if((*i)-&gt;getFace()==NULL)</span>
<a name="l00410"></a>00410       <span class="comment">//  {</span>
<a name="l00411"></a>00411       <span class="comment">//    cout &lt;&lt; "target vertex closest face started as NULL.\n";</span>
<a name="l00412"></a>00412       <span class="comment">//  }</span>
<a name="l00413"></a>00413       <span class="comment">//  else</span>
<a name="l00414"></a>00414       <span class="comment">//  {</span>
<a name="l00415"></a>00415       <span class="comment">//    cout &lt;&lt; "target vertex closest face started as follows.\n";</span>
<a name="l00416"></a>00416       <span class="comment">//    (*i)-&gt;getFace()-&gt;print(cout);</span>
<a name="l00417"></a>00417       <span class="comment">//  }</span>
<a name="l00418"></a>00418       <span class="comment">//}</span>
<a name="l00419"></a>00419       <span class="comment">// DEBUG</span>
<a name="l00420"></a>00420       <span class="comment">// if the closest point to current vertex was found on this face</span>
<a name="l00421"></a>00421       <a class="code" href="classFace.html">Face</a> *cl=NULL;
<a name="l00422"></a>00422       <span class="comment">//if(Container::instance().computeClosest(*j,*i,squareD,norm,true,dummy3))</span>
<a name="l00423"></a>00423       <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> p;
<a name="l00424"></a>00424       <span class="keywordflow">if</span>(<a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().findClosestPtToVertexAmongFaces(*i,cf,p,squareD,cl)==<span class="keyword">true</span>)
<a name="l00425"></a>00425       {
<a name="l00426"></a>00426         gate=<span class="keyword">true</span>;
<a name="l00427"></a>00427         (*i)-&gt;setFace(cl);
<a name="l00428"></a>00428       }
<a name="l00429"></a>00429       <span class="comment">// if new closest point was found</span>
<a name="l00430"></a>00430       <span class="keywordflow">if</span>(gate)
<a name="l00431"></a>00431       {
<a name="l00432"></a>00432         <span class="comment">// DEBUG</span>
<a name="l00433"></a>00433         <span class="comment">//if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true)</span>
<a name="l00434"></a>00434         <span class="comment">//{</span>
<a name="l00435"></a>00435         <span class="comment">//  cout &lt;&lt; "new closest face was found for target vertex.\n";</span>
<a name="l00436"></a>00436         <span class="comment">//}</span>
<a name="l00437"></a>00437         <span class="comment">// DEBUG</span>
<a name="l00438"></a>00438         <span class="comment">// update global energy</span>
<a name="l00439"></a>00439         <span class="comment">// false -&gt; do not compute force, hence dummy</span>
<a name="l00440"></a>00440         <span class="keywordtype">double</span> e=(*i)-&gt;getSeparationForceEnergy(dummy,<span class="keyword">false</span>);
<a name="l00441"></a>00441         <span class="comment">//energy=energy-(*i)-&gt;getEnergy()+e;</span>
<a name="l00442"></a>00442         <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(-(*i)-&gt;getEnergy());
<a name="l00443"></a>00443         <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(e);
<a name="l00444"></a>00444         (*i)-&gt;setEnergy(e);
<a name="l00445"></a>00445         <span class="comment">// update sets with vertex squared virtual displacement</span>
<a name="l00446"></a>00446         <a class="code" href="classVirtual__Disp.html#cfa60cce91fdade84b2030b81d70ad22">Virtual_Disp::instance</a>().<a class="code" href="classVirtual__Disp.html#43b5050d3ef7e1d8d527cf3bbc452b36">updateSets</a>(*i,(*i)-&gt;getSqVirtualDisp(<a class="code" href="classGain__Schedule.html#e9eeedf767171cf65a3fa1ce7728a48d">Gain_Schedule::instance</a>().<a class="code" href="classGain__Schedule.html#c39682e959e22b2ce1a701aa11ab40ad">getGain</a>()));
<a name="l00447"></a>00447       }
<a name="l00448"></a>00448       <span class="keywordflow">else</span>
<a name="l00449"></a>00449       {
<a name="l00450"></a>00450         <span class="comment">// DEBUG</span>
<a name="l00451"></a>00451         <span class="comment">//if((*i)-&gt;isMatch(TARGET_VERTEX_INDEX_1,TARGET_VERTEX_NAME_1)==true)</span>
<a name="l00452"></a>00452         <span class="comment">//{</span>
<a name="l00453"></a>00453         <span class="comment">//  cout &lt;&lt; "new closest face was NOT found for target vertex.\n";</span>
<a name="l00454"></a>00454         <span class="comment">//}</span>
<a name="l00455"></a>00455         <span class="comment">// DEBUG</span>
<a name="l00456"></a>00456       }
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458   }
<a name="l00459"></a>00459 }
<a name="l00460"></a>00460 
<a name="l00461"></a><a class="code" href="classState.html#22ea9a1289727c80e5052eecfcc147bc">00461</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#22ea9a1289727c80e5052eecfcc147bc">State::updateAdjacentFaceBoxes</a> (<a class="code" href="classVertex.html">Vertex</a> <span class="keyword">const</span> * <span class="keyword">const</span> v,<a class="code" href="meshmorph_8h.html#87faf2ec676ddb99351498b29fb1a6b4">mmap_fp_bp</a> &amp; ob)
<a name="l00462"></a>00462 {
<a name="l00463"></a>00463   <span class="comment">// for each adjacent face, update Box*s</span>
<a name="l00464"></a>00464   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> k=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();k!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();k++)
<a name="l00465"></a>00465   {
<a name="l00466"></a>00466     (*k)-&gt;updateBoxes(ob,nb);
<a name="l00467"></a>00467   }
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00470"></a><a class="code" href="classState.html#60534f136a044d35609f8d661b3945cb">00470</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#60534f136a044d35609f8d661b3945cb">State::updateAdjFaceBoundingBoxes</a> (<a class="code" href="classVertex.html">Vertex</a> <span class="keyword">const</span> * <span class="keyword">const</span> v)
<a name="l00471"></a>00471 {
<a name="l00472"></a>00472   <span class="comment">// for each adjacent face, update Box*s</span>
<a name="l00473"></a>00473   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> k=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();k!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();k++)
<a name="l00474"></a>00474   {
<a name="l00475"></a>00475     (*k)-&gt;setBoundingBox();
<a name="l00476"></a>00476   }
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a><a class="code" href="classState.html#03b0c9f9341c92d26172f4b78ce185ef">00479</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#03b0c9f9341c92d26172f4b78ce185ef">State::updateMovedVertexEnergy</a> (<a class="code" href="classVertex.html">Vertex</a> * <span class="keyword">const</span> v)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481   <span class="keywordtype">double</span> dummy[3] = {0.0,0.0,0.0};
<a name="l00483"></a>00483   <span class="comment">// false -&gt; do not compute force, hence dummy</span>
<a name="l00484"></a>00484   <span class="keywordtype">double</span> e=v-&gt;<a class="code" href="classVertex.html#8f644e80776c6065ce7f5196f106c387">getSeparationForceEnergy</a>(dummy,<span class="keyword">false</span>);
<a name="l00485"></a>00485   <span class="comment">//energy=energy-v-&gt;getEnergy()+e;</span>
<a name="l00486"></a>00486   <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(-v-&gt;<a class="code" href="classVertex.html#6da43553ec4bb04bc2eba8ff3da85574">getEnergy</a>());
<a name="l00487"></a>00487   <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(e);
<a name="l00488"></a>00488   v-&gt;<a class="code" href="classVertex.html#51420da58bf0b101f01ba792071f33d6">setEnergy</a>(e);
<a name="l00490"></a>00490   <span class="comment">// for each affected edge</span>
<a name="l00491"></a>00491   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#7bbde133ac39ecfc284c91b3da140e56">ep_cit</a> i=ae.begin();i!=ae.end();i++)
<a name="l00492"></a>00492   {
<a name="l00493"></a>00493     <a class="code" href="classVertex.html">Vertex</a> *v1=NULL,*v2=NULL,*o1=NULL,*o2=NULL;
<a name="l00494"></a>00494     (*i)-&gt;getVertices(v1,v2,o1,o2);
<a name="l00495"></a>00495     <span class="comment">// choice of v1 is arbitrary, v2 could have been used</span>
<a name="l00496"></a>00496     <span class="comment">// false -&gt; do not compute force, hence dummy</span>
<a name="l00497"></a>00497     e=(*i)-&gt;getStretchForceEnergy(v1,dummy,<span class="keyword">false</span>)
<a name="l00498"></a>00498           +(*i)-&gt;getAngleForceEnergy(0,dummy,<span class="keyword">false</span>);
<a name="l00499"></a>00499     <span class="comment">//energy=energy-(*i)-&gt;getEnergy()+e;</span>
<a name="l00500"></a>00500     <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(-(*i)-&gt;getEnergy());
<a name="l00501"></a>00501     <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b47c596a168ca291533f3c3ee0a9091d">updateEnergy</a>(e);
<a name="l00502"></a>00502     (*i)-&gt;setEnergy(e);
<a name="l00503"></a>00503   }
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00514"></a><a class="code" href="classState.html#8ed5ca2a5be6e2c161240f9caaea80b3">00514</a> <span class="keywordtype">void</span> <a class="code" href="classState.html#8ed5ca2a5be6e2c161240f9caaea80b3">State::updateVertexVD</a> (<a class="code" href="classVertex.html">Vertex</a> * <span class="keyword">const</span> v)
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516   <span class="comment">// collect adjacent edges to current vertex</span>
<a name="l00517"></a>00517   <a class="code" href="meshmorph_8h.html#b8f23ead30535aec0b94acd8c2b32c14">vec_ep</a> e;
<a name="l00518"></a>00518   v-&gt;<a class="code" href="classVertex.html#9698fd8ed0d0ecc74b08d25dfeb483d1">getAdjacentEdges</a>(e);
<a name="l00519"></a>00519   <span class="comment">// collect edges from current vertex adjacent faces</span>
<a name="l00520"></a>00520   ae.clear();
<a name="l00521"></a>00521   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=v-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();i!=v-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();i++)
<a name="l00522"></a>00522   {
<a name="l00523"></a>00523     <span class="comment">// store face edges</span>
<a name="l00524"></a>00524     ae.push_back((*i)-&gt;getEdge(0));
<a name="l00525"></a>00525     ae.push_back((*i)-&gt;getEdge(1));
<a name="l00526"></a>00526     ae.push_back((*i)-&gt;getEdge(2));
<a name="l00527"></a>00527   }
<a name="l00528"></a>00528   <span class="comment">// sort and keep unique </span>
<a name="l00529"></a>00529   sort(ae.begin(),ae.end());
<a name="l00530"></a>00530   ae.assign(ae.begin(),unique(ae.begin(),ae.end()));
<a name="l00531"></a>00531   <span class="comment">// set for storing nearby vertices to update</span>
<a name="l00532"></a>00532   <a class="code" href="meshmorph_8h.html#f53009c47e4e310b71887703aee4ec17">v_set</a> nearby;
<a name="l00533"></a>00533   <span class="comment">// for each collected edge from current vertex adjacent faces</span>
<a name="l00534"></a>00534   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#2c2a5a920658be1c063b7bb97132ad02">ep_it</a> i=ae.begin();i!=ae.end();i++)
<a name="l00535"></a>00535   {
<a name="l00536"></a>00536     <span class="comment">// if edge is not adjacent to current vertex</span>
<a name="l00537"></a>00537     <span class="keywordflow">if</span>( find(e.begin(),e.end(),*i)==e.end())
<a name="l00538"></a>00538     {
<a name="l00539"></a>00539       <a class="code" href="classVertex.html">Vertex</a> *v1,*v2,*o1,*o2;
<a name="l00540"></a>00540       (*i)-&gt;getVertices(v1,v2,o1,o2);
<a name="l00541"></a>00541       <span class="comment">// insert all four edge vertices (v1,v2,o1,o2) into set</span>
<a name="l00542"></a>00542       nearby.insert(v1);
<a name="l00543"></a>00543       nearby.insert(v2);
<a name="l00544"></a>00544       nearby.insert(o1);
<a name="l00545"></a>00545       nearby.insert(o2);
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547   }
<a name="l00548"></a>00548   <span class="comment">// update collected vertices including current vertex</span>
<a name="l00549"></a>00549   <span class="comment">// for each collected vertex</span>
<a name="l00550"></a>00550   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#6a736ea70531f4c1ebd26c9551894045">vs_it</a> i=nearby.begin();i!=nearby.end();i++)
<a name="l00551"></a>00551   {
<a name="l00552"></a>00552     <span class="comment">// if vertex has a closest point, then update sets</span>
<a name="l00553"></a>00553     <span class="keywordflow">if</span>((*i)-&gt;getFace()!=NULL)
<a name="l00554"></a>00554     {
<a name="l00555"></a>00555       <a class="code" href="classVirtual__Disp.html#cfa60cce91fdade84b2030b81d70ad22">Virtual_Disp::instance</a>().<a class="code" href="classVirtual__Disp.html#43b5050d3ef7e1d8d527cf3bbc452b36">updateSets</a>(*i,(*i)-&gt;getSqVirtualDisp(<a class="code" href="classGain__Schedule.html#e9eeedf767171cf65a3fa1ce7728a48d">Gain_Schedule::instance</a>().<a class="code" href="classGain__Schedule.html#c39682e959e22b2ce1a701aa11ab40ad">getGain</a>()));
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557   }
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 
<a name="l00560"></a><a class="code" href="classState.html#861d67b91c2ef3f470ff507764faa8e4">00560</a> <span class="keywordtype">bool</span> <a class="code" href="classState.html#861d67b91c2ef3f470ff507764faa8e4">State::assignNewVertexCoords</a> (<a class="code" href="classVertex.html">Vertex</a> * <span class="keyword">const</span> v,<a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> <span class="keyword">const</span> &amp; p,<span class="keywordtype">bool</span> &amp;int_flag,<span class="keywordtype">bool</span> &amp;angle_flag)
<a name="l00561"></a>00561 {
<a name="l00562"></a>00562   <a class="code" href="classIntersecting__Faces.html">Intersecting_Faces</a> &amp; i_f(<a class="code" href="classIntersecting__Faces.html#8ccec8bb3cfc50e4ad98ff13c1f8ec8f">Intersecting_Faces::instance</a>());
<a name="l00563"></a>00563   <span class="comment">// build old face* hashtable</span>
<a name="l00564"></a>00564   <a class="code" href="meshmorph_8h.html#87faf2ec676ddb99351498b29fb1a6b4">mmap_fp_bp</a> ob = <a class="code" href="classState.html#5a6de40ee1c1a4926ed2c0a991845582">getOrigBoxesOfVertAdjFaces</a>(v);
<a name="l00565"></a>00565   <span class="comment">// clear new face* hashtable</span>
<a name="l00566"></a>00566   <a class="code" href="classState.html#0a7a4a8734109f6bebf3517226e52ca3">clearNewFaces</a>();
<a name="l00567"></a>00567   <span class="comment">// store current vertex position</span>
<a name="l00568"></a>00568   <span class="keywordtype">double</span> pO[3]={v-&gt;<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(0),v-&gt;<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(1),v-&gt;<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(2)};
<a name="l00569"></a>00569   <span class="comment">// collect vertices in a local region</span>
<a name="l00570"></a>00570   <span class="comment">// whose closest point is on adjacent face of current vertex</span>
<a name="l00571"></a>00571   <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> fs = <a class="code" href="classState.html#8735800613feb7b4fa430344bfef6ee8">getVertsForFullClosestPtSearch</a>(v);
<a name="l00572"></a>00572   <span class="comment">// collect edge angles</span>
<a name="l00573"></a>00573   <a class="code" href="classState.html#084f05cd6f8edc9416b864a0e5511ffb">collectEdgeAngles</a>(v);
<a name="l00574"></a>00574   <span class="comment">// set current position to holding position</span>
<a name="l00575"></a>00575   v-&gt;<a class="code" href="classVertex.html#e040870740fe8b0c7e86b013914843fe">setNewPos</a>(p);
<a name="l00576"></a>00576   <span class="comment">// add to previous collection of vertices the collection </span>
<a name="l00577"></a>00577   <span class="comment">// of all vertices in the same local region as before</span>
<a name="l00578"></a>00578   <span class="comment">// also collect edges of adjacent faces of current vertex</span>
<a name="l00579"></a>00579   <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> ps = <a class="code" href="classState.html#b8df6ba93c188015d8951e130f89bcdc">getVertsForPartialClosestPtSearch</a>(v);
<a name="l00580"></a>00580   <span class="comment">// if no faces intersect and no edges have small angles</span>
<a name="l00581"></a>00581   int_flag = (i_f.<a class="code" href="classIntersecting__Faces.html#d0b9954e791421bbdbcdc0aa6bc13a88">vertAdjFacesHaveNewInt</a>(v) &amp;&amp; <a class="code" href="controls_8h.html#998fb5a621f6ed21c22b9a2905b5264c">INTERSECTION_WEIGHT</a>!=100.0);
<a name="l00582"></a>00582   angle_flag = <a class="code" href="classState.html#cd3aa3488c0124d7d4774ff0f7250685">State::instance</a>().<a class="code" href="classState.html#6ef63974502bb099b71cc76b56da7f57">smallAnglesFound</a>();
<a name="l00583"></a>00583   <span class="keywordflow">if</span> (int_flag==<span class="keyword">false</span> &amp;&amp; angle_flag==<span class="keyword">false</span>)
<a name="l00584"></a>00584   {
<a name="l00585"></a>00585     <span class="comment">// for each adjacent face, update Box*s</span>
<a name="l00586"></a>00586     <a class="code" href="classState.html#22ea9a1289727c80e5052eecfcc147bc">updateAdjacentFaceBoxes</a>(v,ob);
<a name="l00587"></a>00587     <span class="comment">// for each adjacent face, update bounding box</span>
<a name="l00588"></a>00588     <a class="code" href="classState.html#60534f136a044d35609f8d661b3945cb">updateAdjFaceBoundingBoxes</a>(v);
<a name="l00589"></a>00589     <span class="comment">// process intersecting faces, if any</span>
<a name="l00590"></a>00590     <span class="keywordflow">if</span>(i_f.<a class="code" href="classIntersecting__Faces.html#a1a58bcebe21681324ab18ac410383b2">getCountOfIntFaces</a>(<span class="keyword">false</span>)&gt;0)
<a name="l00591"></a>00591     {
<a name="l00592"></a>00592       <span class="comment">// store vertices for which niceness may have changed</span>
<a name="l00593"></a>00593       <span class="comment">// i.e. vertices of faces that were intersected</span>
<a name="l00594"></a>00594       <span class="comment">// but now aren't, and vice versa</span>
<a name="l00595"></a>00595       <a class="code" href="meshmorph_8h.html#274b35739790732fd62f8771c082edb0">hashset_v</a> ni = i_f.<a class="code" href="classIntersecting__Faces.html#540d46017e3f03c2e26052b31e99ded1">getNiceCheckSet</a>(v);
<a name="l00596"></a>00596       <span class="comment">// detect niceness changes and collect changed vertices</span>
<a name="l00597"></a>00597       i_f.<a class="code" href="classIntersecting__Faces.html#315e085f96a18a8cbb7d1bf788e5e029">getNiceSet</a>(fs,ni);
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599     <span class="comment">// update closest point and global energy </span>
<a name="l00600"></a>00600     <span class="comment">// for affected vertices collected before</span>
<a name="l00601"></a>00601     <a class="code" href="classState.html#0215b7e7094ff53afd64e460547010ca">updateClosestFaceToVertices</a>(v,fs,ps);
<a name="l00602"></a>00602     <span class="comment">// update sets with squared virtual displacement of nearby vertices</span>
<a name="l00603"></a>00603     <a class="code" href="classState.html#8ed5ca2a5be6e2c161240f9caaea80b3">updateVertexVD</a>(v);
<a name="l00604"></a>00604     <span class="comment">// update global energy due to this vertex</span>
<a name="l00605"></a>00605     <a class="code" href="classState.html#03b0c9f9341c92d26172f4b78ce185ef">updateMovedVertexEnergy</a>(v);
<a name="l00606"></a>00606     <span class="comment">// DEBUG</span>
<a name="l00607"></a>00607 <span class="comment">//    if (ENABLE_VTRACK==true)</span>
<a name="l00608"></a>00608 <span class="comment">//    {</span>
<a name="l00609"></a>00609 <span class="comment">//      cout &lt;&lt; "Vertices undergoing full closest point search\n"</span>
<a name="l00610"></a>00610 <span class="comment">//           &lt;&lt; "*********************************************\n";</span>
<a name="l00611"></a>00611 <span class="comment">//      for (vp_it i=fs.begin();i!=fs.end();i++)</span>
<a name="l00612"></a>00612 <span class="comment">//      {</span>
<a name="l00613"></a>00613 <span class="comment">//        (*i)-&gt;print(cout);</span>
<a name="l00614"></a>00614 <span class="comment">//      }</span>
<a name="l00615"></a>00615 <span class="comment">//      cout &lt;&lt; "*********************************************\n";</span>
<a name="l00616"></a>00616 <span class="comment">//      cout &lt;&lt; "Vertices undergoing partial closest point search\n"</span>
<a name="l00617"></a>00617 <span class="comment">//           &lt;&lt; "*********************************************\n";</span>
<a name="l00618"></a>00618 <span class="comment">//      for (vp_it i=ps.begin();i!=ps.end();i++)</span>
<a name="l00619"></a>00619 <span class="comment">//      {</span>
<a name="l00620"></a>00620 <span class="comment">//        (*i)-&gt;print(cout);</span>
<a name="l00621"></a>00621 <span class="comment">//      }</span>
<a name="l00622"></a>00622 <span class="comment">//      cout &lt;&lt; "*********************************************\n";</span>
<a name="l00623"></a>00623 <span class="comment">//      cout &lt;&lt; "num verts in full    search = " &lt;&lt; fs.size() &lt;&lt; endl</span>
<a name="l00624"></a>00624 <span class="comment">//           &lt;&lt; "num verts in partial search = " &lt;&lt; ps.size() &lt;&lt; endl;</span>
<a name="l00625"></a>00625 <span class="comment">//    }</span>
<a name="l00626"></a>00626     <span class="comment">// DEBUG</span>
<a name="l00627"></a>00627     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629   <span class="keywordflow">else</span>
<a name="l00630"></a>00630   {
<a name="l00631"></a>00631     <span class="comment">// move vertex back</span>
<a name="l00632"></a>00632     v-&gt;<a class="code" href="classVertex.html#ecaaf6dcf64506a27218cb7a173cf6dd">setPos</a>(pO[0],pO[1],pO[2]);
<a name="l00633"></a>00633     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00634"></a>00634   }
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a><a class="code" href="classState.html#6ef63974502bb099b71cc76b56da7f57">00637</a> <span class="keywordtype">bool</span> <a class="code" href="classState.html#6ef63974502bb099b71cc76b56da7f57">State::smallAnglesFound</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00638"></a>00638 <span class="keyword"></span>{
<a name="l00639"></a>00639   <span class="comment">// for each element in hashtable (edge*-&gt;double)</span>
<a name="l00640"></a>00640   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#b5e1a0b43c544ac2f3c9a45a7c1ead49">edhm_cit</a> j=ea.begin();j!=ea.end();j++)
<a name="l00641"></a>00641   {
<a name="l00642"></a>00642     <span class="comment">// if edge angle is less than threshold</span>
<a name="l00643"></a>00643     <span class="comment">// and if angle change is in wrong direction, then return true</span>
<a name="l00644"></a>00644     <span class="keywordtype">double</span> new_angle=(*j).first-&gt;getAngle();
<a name="l00645"></a>00645     <span class="comment">// small new_angles are acceptable if old_angle was also small and angle is improving</span>
<a name="l00646"></a>00646     <span class="comment">// if new angle is small</span>
<a name="l00647"></a>00647     <span class="keywordflow">if</span> (fabs(new_angle)&lt;<a class="code" href="controls_8h.html#53f19bb9ccf2ab54c99133834e70827b">EDGE_ANGLE_THRESHOLD</a> || fabs(2*<a class="code" href="controls_8h.html#952eac791b596a61bba0a133a3bb439f">PI</a>-new_angle)&lt;<a class="code" href="controls_8h.html#53f19bb9ccf2ab54c99133834e70827b">EDGE_ANGLE_THRESHOLD</a>)
<a name="l00648"></a>00648     {
<a name="l00649"></a>00649       <span class="comment">// if old angle is not small or angle change is wrong, then return true</span>
<a name="l00650"></a>00650       <span class="keywordflow">if</span>(   !(fabs((*j).second)&lt;<a class="code" href="controls_8h.html#53f19bb9ccf2ab54c99133834e70827b">EDGE_ANGLE_THRESHOLD</a>  ||
<a name="l00651"></a>00651          fabs(2*<a class="code" href="controls_8h.html#952eac791b596a61bba0a133a3bb439f">PI</a>-(*j).second)&lt;<a class="code" href="controls_8h.html#53f19bb9ccf2ab54c99133834e70827b">EDGE_ANGLE_THRESHOLD</a>) ||
<a name="l00652"></a>00652             <a class="code" href="classState.html#6651e8fa330ef74555c15072fd36e0f1">angleChangeIsWrong</a>((*j).second,new_angle) )
<a name="l00653"></a>00653       {
<a name="l00654"></a>00654         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00655"></a>00655       }
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657   }
<a name="l00658"></a>00658   <span class="comment">// no adjacent edges of current vertex violate edge angle threshold</span>
<a name="l00659"></a>00659   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="classState.html#6651e8fa330ef74555c15072fd36e0f1">00662</a> <span class="keywordtype">bool</span> <a class="code" href="classState.html#6651e8fa330ef74555c15072fd36e0f1">State::angleChangeIsWrong</a> (<span class="keywordtype">double</span> old_angle,<span class="keywordtype">double</span> new_angle)<span class="keyword"> const</span>
<a name="l00663"></a>00663 <span class="keyword"></span>{
<a name="l00664"></a>00664   <span class="keywordflow">if</span> (old_angle &lt; <a class="code" href="controls_8h.html#952eac791b596a61bba0a133a3bb439f">PI</a>)
<a name="l00665"></a>00665   {
<a name="l00666"></a>00666     <span class="comment">// angle should increase towards PI</span>
<a name="l00667"></a>00667     <span class="comment">// angle increase is correct</span>
<a name="l00668"></a>00668     <span class="comment">// if angle increases, return false</span>
<a name="l00669"></a>00669     <span class="comment">// if angle decreases, return true</span>
<a name="l00670"></a>00670     <span class="keywordflow">if</span> ( new_angle&gt;old_angle )  {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00671"></a>00671     <span class="keywordflow">else</span>                        {<span class="keywordflow">return</span> <span class="keyword">true</span>;} 
<a name="l00672"></a>00672   }
<a name="l00673"></a>00673   <span class="keywordflow">else</span>
<a name="l00674"></a>00674   {
<a name="l00675"></a>00675     <span class="comment">// assume old_angle &gt; PI, i.e. not exactly PI</span>
<a name="l00676"></a>00676     <span class="comment">// angle should decrease towards PI</span>
<a name="l00677"></a>00677     <span class="comment">// angle decrease is correct</span>
<a name="l00678"></a>00678     <span class="comment">// if angle decreases, return false</span>
<a name="l00679"></a>00679     <span class="comment">// if angle increases, return true</span>
<a name="l00680"></a>00680     <span class="keywordflow">if</span> ( new_angle&lt;old_angle )  {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00681"></a>00681     <span class="keywordflow">else</span>                        {<span class="keywordflow">return</span> <span class="keyword">true</span>;} 
<a name="l00682"></a>00682   }
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Jul 18 19:43:40 2008 for meshmorph by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
