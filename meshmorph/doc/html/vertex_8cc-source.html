<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>meshmorph: vertex.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>vertex.cc</h1><a href="vertex_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include "<a class="code" href="vertex_8h.html">vertex.h</a>"</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="container_8h.html">container.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="edge_8h.html">edge.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="face_8h.html">face.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="intersecting__faces_8h.html">intersecting_faces.h</a>"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="misc_8h.html">misc.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "<a class="code" href="nice_8h.html">nice.h</a>"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="object_8h.html">object.h</a>"</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="keyword">using</span> std::cout;
<a name="l00016"></a>00016 <span class="keyword">using</span> std::endl;
<a name="l00017"></a>00017 
<a name="l00018"></a><a class="code" href="classVertex.html#42156e0f7298c47e00f172a5f504028a">00018</a> <a class="code" href="classVertex.html#bf0db481ea801a16103175c0ad35a435">Vertex::Vertex</a> (<span class="keyword">const</span> <a class="code" href="classVertex.html">Vertex</a>&amp; rhs)
<a name="l00019"></a>00019   :index(rhs.index),p(rhs.p),cl(rhs.cl),o(rhs.o),
<a name="l00020"></a>00020   f(rhs.f),energy(rhs.energy)
<a name="l00021"></a>00021 {
<a name="l00022"></a>00022 }
<a name="l00023"></a>00023 
<a name="l00024"></a><a class="code" href="classVertex.html#d20da0d28fba10d6151cc8c5d756fff6">00024</a> <a class="code" href="classVertex.html">Vertex</a>&amp; <a class="code" href="classVertex.html#d20da0d28fba10d6151cc8c5d756fff6">Vertex::operator = </a>(<span class="keyword">const</span> <a class="code" href="classVertex.html">Vertex</a>&amp; rhs)
<a name="l00025"></a>00025 {
<a name="l00026"></a>00026   cout &lt;&lt; <span class="stringliteral">"Assignment operator prohibited on instances of vertex class.\n"</span>;
<a name="l00027"></a>00027   cout &lt;&lt; <span class="stringliteral">"Vertex "</span> &lt;&lt; rhs.<a class="code" href="classVertex.html#2e35f7521dfd3fdee65dc26879c62f24">index</a> &lt;&lt; endl;
<a name="l00028"></a>00028   exit(0);
<a name="l00029"></a>00029 }
<a name="l00030"></a>00030 
<a name="l00037"></a><a class="code" href="classVertex.html#bf0db481ea801a16103175c0ad35a435">00037</a> <a class="code" href="classVertex.html#bf0db481ea801a16103175c0ad35a435">Vertex::Vertex</a> (<span class="keywordtype">char</span> <span class="keyword">const</span> * triplet,<a class="code" href="classObject.html">Object</a> * <span class="keyword">const</span> q)
<a name="l00038"></a>00038   :index(0),p(),cl(NULL),o(q),f(),energy(0)
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040   <span class="keywordtype">int</span> i;
<a name="l00041"></a>00041   <span class="keywordtype">char</span> val[80];
<a name="l00042"></a>00042   <span class="keywordtype">char</span> * eptr;
<a name="l00043"></a>00043   <span class="keywordtype">char</span> <span class="keyword">const</span> * cp = triplet;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <span class="comment">// get past 'Vertex'</span>
<a name="l00046"></a>00046   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">"Vertx"</span>,*triplet)!=NULL) {triplet++;}
<a name="l00047"></a>00047 
<a name="l00048"></a>00048   <span class="comment">// grab vertex index</span>
<a name="l00049"></a>00049   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">" \t,"</span>,*triplet)!=NULL) {triplet++;}
<a name="l00050"></a>00050   i=0;
<a name="l00051"></a>00051   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">"0123456789+-eE."</span>,*triplet)!=NULL)
<a name="l00052"></a>00052   {
<a name="l00053"></a>00053     val[i++] = *triplet++;
<a name="l00054"></a>00054   }
<a name="l00055"></a>00055   val[i]=0;
<a name="l00056"></a>00056   index = (int) strtod(val,&amp;eptr);
<a name="l00057"></a>00057   <span class="keywordflow">if</span> (val==eptr)
<a name="l00058"></a>00058   {
<a name="l00059"></a>00059     index=0;
<a name="l00060"></a>00060     printf(<span class="stringliteral">"Error in reading vertex index\n"</span>);
<a name="l00061"></a>00061     <span class="keywordflow">return</span>;
<a name="l00062"></a>00062   }
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   <span class="comment">// grab x coord</span>
<a name="l00065"></a>00065   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">" \t,"</span>,*triplet)!=NULL) {triplet++;}
<a name="l00066"></a>00066   i=0;
<a name="l00067"></a>00067   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">"0123456789+-eE."</span>,*triplet)!=NULL)
<a name="l00068"></a>00068   {
<a name="l00069"></a>00069     val[i++] = *triplet++;
<a name="l00070"></a>00070   }
<a name="l00071"></a>00071   val[i]=0;
<a name="l00072"></a>00072   p.push_back(strtod(val,&amp;eptr));
<a name="l00073"></a>00073   <span class="keywordflow">if</span> (val==eptr)
<a name="l00074"></a>00074   {
<a name="l00075"></a>00075     printf(<span class="stringliteral">"Error in reading vertex\n"</span>);
<a name="l00076"></a>00076     printf(<span class="stringliteral">"Error in reading vertex: string %s\n"</span>,cp);
<a name="l00077"></a>00077     <span class="keywordflow">return</span>;
<a name="l00078"></a>00078   }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">// grab y coord</span>
<a name="l00081"></a>00081   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">" \t,"</span>,*triplet)!=NULL) triplet++;
<a name="l00082"></a>00082   i=0;
<a name="l00083"></a>00083   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">"0123456789+-eE."</span>,*triplet))
<a name="l00084"></a>00084   {
<a name="l00085"></a>00085     val[i++] = *triplet++;
<a name="l00086"></a>00086   }
<a name="l00087"></a>00087   val[i]=0;
<a name="l00088"></a>00088   p.push_back(strtod(val,&amp;eptr));
<a name="l00089"></a>00089   <span class="keywordflow">if</span> (val==eptr)
<a name="l00090"></a>00090   {
<a name="l00091"></a>00091     printf(<span class="stringliteral">"Error in reading vertex\n"</span>);
<a name="l00092"></a>00092     printf(<span class="stringliteral">"Error in reading vertex: string %s\n"</span>,cp);
<a name="l00093"></a>00093     <span class="keywordflow">return</span>;
<a name="l00094"></a>00094   }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <span class="comment">// grab z coord</span>
<a name="l00097"></a>00097   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">" \t,"</span>,*triplet)!=NULL) triplet++;
<a name="l00098"></a>00098   i=0;
<a name="l00099"></a>00099   <span class="keywordflow">while</span> (strchr(<span class="stringliteral">"0123456789+-eE."</span>,*triplet))
<a name="l00100"></a>00100   {
<a name="l00101"></a>00101     val[i++] = *triplet++;
<a name="l00102"></a>00102   }
<a name="l00103"></a>00103   val[i]=0;
<a name="l00104"></a>00104   p.push_back(strtod(val,&amp;eptr));
<a name="l00105"></a>00105   <span class="keywordflow">if</span> (val==eptr)
<a name="l00106"></a>00106   {
<a name="l00107"></a>00107     printf(<span class="stringliteral">"Error in reading vertex\n"</span>);
<a name="l00108"></a>00108     printf(<span class="stringliteral">"Error in reading vertex: string %s\n"</span>,cp);
<a name="l00109"></a>00109     <span class="keywordflow">return</span>;
<a name="l00110"></a>00110   }
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00118"></a><a class="code" href="classVertex.html#0487c340a3a1559f4a8e45d8a7b0f9e2">00118</a> <span class="keywordtype">int</span> <a class="code" href="classVertex.html#0487c340a3a1559f4a8e45d8a7b0f9e2">Vertex::getIndex</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00119"></a>00119 <span class="keyword"></span>{
<a name="l00120"></a>00120   <span class="keywordflow">return</span> index;
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00128"></a><a class="code" href="classVertex.html#ef328a4374db75403a25eb165c1b7066">00128</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#ef328a4374db75403a25eb165c1b7066">Vertex::print</a> (std::ostream &amp; target)<span class="keyword"> const</span>
<a name="l00129"></a>00129 <span class="keyword"></span>{
<a name="l00130"></a>00130   <span class="keywordtype">char</span> <a class="code" href="meshmorph_8h.html#8be94bb2c91eeb8bba8970efa1a18fd0">str</a>[1024];
<a name="l00131"></a>00131   sprintf(str,<span class="stringliteral">"Vertex &lt;obj&gt; %s &lt;ind&gt; %d"</span>,o-&gt;<a class="code" href="classObject.html#cc8484b3d564307b5bd801b907b0d72f">getName</a>().c_str(),index);
<a name="l00132"></a>00132   sprintf(str,<span class="stringliteral">"%s [%.15g %.15g %.15g]\n"</span>,str,p[0],p[1],p[2]);
<a name="l00133"></a>00133   target &lt;&lt; str;
<a name="l00134"></a>00134 }
<a name="l00135"></a>00135 
<a name="l00142"></a><a class="code" href="classVertex.html#277422e73e7ec49cec4239bfe0b98dbb">00142</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#277422e73e7ec49cec4239bfe0b98dbb">Vertex::printCP</a> (std::ostream &amp;target)<span class="keyword"> const</span>
<a name="l00143"></a>00143 <span class="keyword"></span>{
<a name="l00144"></a>00144   <span class="keywordtype">char</span> <a class="code" href="meshmorph_8h.html#8be94bb2c91eeb8bba8970efa1a18fd0">str</a>[1024];
<a name="l00145"></a>00145   sprintf(str,<span class="stringliteral">"%.15g %.15g %.15g 1 0 0 1\n"</span>,p[0],p[1],p[2]);
<a name="l00146"></a>00146   target &lt;&lt; str;
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00157"></a><a class="code" href="classVertex.html#c1760566520fd16501b2cfb47f2b4398">00157</a> <span class="keywordtype">bool</span> <a class="code" href="classVertex.html#c1760566520fd16501b2cfb47f2b4398">Vertex::isMatch</a> (<span class="keywordtype">int</span> <span class="keyword">const</span> i, <a class="code" href="meshmorph_8h.html#8be94bb2c91eeb8bba8970efa1a18fd0">str</a> <span class="keyword">const</span> name)<span class="keyword"> const</span>
<a name="l00158"></a>00158 <span class="keyword"></span>{
<a name="l00159"></a>00159   <span class="keywordflow">return</span> i==index &amp;&amp; name==o-&gt;<a class="code" href="classObject.html#cc8484b3d564307b5bd801b907b0d72f">getName</a>();
<a name="l00160"></a>00160 }
<a name="l00168"></a><a class="code" href="classVertex.html#fa014c28611c6762ea25094dd1401306">00168</a> <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> <a class="code" href="classVertex.html#fa014c28611c6762ea25094dd1401306">Vertex::getNormal</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00169"></a>00169 <span class="keyword"></span>{
<a name="l00170"></a>00170   <span class="keywordtype">double</span> theta,thetaT=0.0,L;
<a name="l00171"></a>00171   <span class="comment">//n[0]=n[1]=n[2]=0;</span>
<a name="l00172"></a>00172   <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> n(3,.00);
<a name="l00173"></a>00173   <span class="comment">// for each adjacent face</span>
<a name="l00174"></a>00174   <span class="keywordflow">for</span> (<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=f.begin();i!=f.end();i++)
<a name="l00175"></a>00175   {
<a name="l00176"></a>00176     <span class="comment">// get coordinates of polygon normal</span>
<a name="l00177"></a>00177     <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> t = (*i)-&gt;getNormal();
<a name="l00178"></a>00178     L=sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);
<a name="l00179"></a>00179     <span class="comment">//theta=(*i)-&gt;getAngle(this);</span>
<a name="l00180"></a>00180     theta=(*i)-&gt;getAngleProxy(<span class="keyword">this</span>);
<a name="l00181"></a>00181     thetaT+=theta;
<a name="l00182"></a>00182     <span class="comment">// and add to sum</span>
<a name="l00183"></a>00183     <span class="keywordtype">double</span> a = theta/L;
<a name="l00184"></a>00184     n[0] += t[0]*a;
<a name="l00185"></a>00185     n[1] += t[1]*a;
<a name="l00186"></a>00186     n[2] += t[2]*a;
<a name="l00187"></a>00187   }
<a name="l00188"></a>00188   <span class="keywordtype">double</span> a = 1.0/f.size()/thetaT;
<a name="l00189"></a>00189   n[0] = n[0]*a;
<a name="l00190"></a>00190   n[1] = n[1]*a;
<a name="l00191"></a>00191   n[2] = n[2]*a;
<a name="l00192"></a>00192   <span class="keywordflow">return</span> n;
<a name="l00193"></a>00193 }
<a name="l00194"></a>00194 
<a name="l00204"></a><a class="code" href="classVertex.html#8f644e80776c6065ce7f5196f106c387">00204</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#8f644e80776c6065ce7f5196f106c387">Vertex::getSeparationForceEnergy</a> (<span class="keywordtype">double</span> * <span class="keyword">const</span> &amp;force,<span class="keywordtype">bool</span> compute_force)<span class="keyword"> const</span>
<a name="l00205"></a>00205 <span class="keyword"></span>{
<a name="l00206"></a>00206   <span class="keywordflow">if</span>(cl!=NULL)
<a name="l00207"></a>00207   {
<a name="l00208"></a>00208     <span class="comment">// get closest point</span>
<a name="l00209"></a>00209     <span class="comment">//double pC[3];</span>
<a name="l00210"></a>00210     <span class="comment">//vec_d pC = Container::instance().getNearPtOnFaceToVertex(cl,this);</span>
<a name="l00211"></a>00211     <a class="code" href="meshmorph_8h.html#1f34905de522641c355a51fe9e3f1149">vec_fp</a> fp(1,cl);
<a name="l00212"></a>00212     <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> dummy_p;
<a name="l00213"></a>00213     <span class="keywordtype">double</span> sqd=0.0;
<a name="l00214"></a>00214     <a class="code" href="classFace.html">Face</a> *dummy_ncl = NULL;
<a name="l00215"></a>00215     <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b2dcd71e2d3a21f3977a9de3c49e99c9">findClosestPtToVertexAmongFaces</a>(<span class="keyword">this</span>,fp,dummy_p,sqd,dummy_ncl);
<a name="l00216"></a>00216     <span class="comment">// DEBUG</span>
<a name="l00217"></a>00217     <span class="comment">//assert(sqd&lt;1E10);</span>
<a name="l00218"></a>00218     <span class="comment">//assert(sqd==sqd);</span>
<a name="l00219"></a>00219     <span class="comment">// DEBUG</span>
<a name="l00220"></a>00220     <span class="comment">// compute separation vector</span>
<a name="l00221"></a>00221     <span class="comment">//double s[3];</span>
<a name="l00222"></a>00222     <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> s(3,0);
<a name="l00223"></a>00223     <span class="comment">//for(int i=0;i&lt;3;i++){ s[i]=pC[i]-p[i]; }</span>
<a name="l00224"></a>00224     <span class="comment">// compute separation distance //////////</span>
<a name="l00225"></a>00225     <span class="keywordtype">double</span> sd = sqrt(sqd);
<a name="l00226"></a>00226     <span class="comment">// compute separation error (signed value)</span>
<a name="l00227"></a>00227     <span class="comment">// NOTE THIS ASSUMES VERTEX IS INSIDE SAME OBJECT</span>
<a name="l00228"></a>00228     <span class="comment">// ON WHICH CLOSEST POINT WAS FOUND, OTHERWISE</span>
<a name="l00229"></a>00229     <span class="comment">// OTHERWISE SE!=sd+TARGET_SEPARATION</span>
<a name="l00230"></a>00230     <span class="comment">// also note that se=sd+TARGET_SEPARATION is correct</span>
<a name="l00231"></a>00231     <span class="comment">// for nonnice vertex, since pC-p is oriented so as</span>
<a name="l00232"></a>00232     <span class="comment">// to move vertex out of violated object</span>
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     <span class="comment">// set target separation</span>
<a name="l00235"></a>00235     <span class="keywordtype">double</span> TS = <a class="code" href="controls_8h.html#c68779a10c10fbaad4c9cf6a9343e8b5">TARGET_SEPARATION</a>*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;
<a name="l00236"></a>00236     <span class="comment">// if closest face is inside vertex neighborhood</span>
<a name="l00237"></a>00237     <span class="comment">//if(Container::instance().faceInNeighborhood(cl,this)==true){ TS = LOOP_TARGET_SEPARATION*SCALE; }</span>
<a name="l00238"></a>00238     <span class="comment">//else { TS = TARGET_SEPARATION*SCALE; }</span>
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     <span class="keywordtype">double</span> se;
<a name="l00241"></a>00241     <span class="keywordflow">if</span>(<a class="code" href="classNice.html#0e7a8f2b7f6c9e5a41b4f0a106a7614e">Nice::instance</a>().vertexIsNice(<span class="keyword">this</span>)==<span class="keyword">false</span>)
<a name="l00242"></a>00242     {
<a name="l00243"></a>00243       se=sd+TS;
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     <span class="keywordflow">else</span>
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247       se=sd-TS;
<a name="l00248"></a>00248     }
<a name="l00249"></a>00249     <span class="keywordflow">if</span>(<a class="code" href="controls_8h.html#c68779a10c10fbaad4c9cf6a9343e8b5">TARGET_SEPARATION</a>==0)
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251       cout &lt;&lt; <span class="stringliteral">"Vertex::getSeparationForceEnergy: we got problems."</span>
<a name="l00252"></a>00252             &lt;&lt; <span class="stringliteral">"TARGET_SEPARATION==0.\n"</span>;
<a name="l00253"></a>00253       exit(0);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     se = se/<a class="code" href="controls_8h.html#c68779a10c10fbaad4c9cf6a9343e8b5">TARGET_SEPARATION</a>;
<a name="l00256"></a>00256     <span class="comment">// if pC==p, i.e. curretn vertex is on surface of neighbor object</span>
<a name="l00257"></a>00257     <span class="comment">// then use current vertex outward normal as separation vector</span>
<a name="l00258"></a>00258     <span class="comment">// recompute separation distance since it is used as normalization factor</span>
<a name="l00259"></a>00259     <span class="keywordflow">if</span> (!sd)
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261       s = <a class="code" href="classVertex.html#fa014c28611c6762ea25094dd1401306">getNormal</a>();
<a name="l00262"></a>00262       sd = sqrt(<a class="code" href="misc_8cc.html#aa2064e9e93d580841bffe746925cc8f">dot</a>(s,s));
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264     <span class="keywordflow">if</span>(compute_force==<span class="keyword">true</span>)
<a name="l00265"></a>00265     {
<a name="l00266"></a>00266       <span class="comment">// spring_force = spring constant * stretch</span>
<a name="l00267"></a>00267       <span class="comment">// let scaled_spring force = spring_force/separation_distance</span>
<a name="l00268"></a>00268       <span class="comment">// Note SEPARATION_WEIGHT has already been normalized to 0 to 1.</span>
<a name="l00269"></a>00269       <span class="keywordtype">double</span> scaled_spring_force = <a class="code" href="controls_8h.html#bb698816fdfaf933d9e354424dd176ee">SEPARATION_GAIN</a>*<a class="code" href="controls_8h.html#33800177cc4bff4c38e6be81afc9ae67">SEPARATION_WEIGHT</a>*se/sd;
<a name="l00270"></a>00270       <span class="comment">// force cartesian component = spring_force * unit vector</span>
<a name="l00271"></a>00271       <span class="comment">// where unit vector = cartesian separation_distance component / separation_distance</span>
<a name="l00272"></a>00272       <span class="comment">// force cartesian component = scaled_spring_force * cartesian separation_distance component</span>
<a name="l00273"></a>00273       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;3;i++) force[i]+=scaled_spring_force*s[i];
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275     <span class="comment">// return energy</span>
<a name="l00276"></a>00276     <span class="keywordflow">return</span> <a class="code" href="controls_8h.html#33800177cc4bff4c38e6be81afc9ae67">SEPARATION_WEIGHT</a>/2.0*se*se;
<a name="l00277"></a>00277   }
<a name="l00278"></a>00278   <span class="keywordflow">else</span>
<a name="l00279"></a>00279   {
<a name="l00280"></a>00280     <span class="comment">// cl==NULL, i.e. no closest point</span>
<a name="l00281"></a>00281     <span class="comment">// therefore no contribution to force</span>
<a name="l00282"></a>00282     <span class="comment">// peg energy at maximum possible value, i.e. max separation error</span>
<a name="l00283"></a>00283     <span class="comment">// maximum separation error would occur when closest point found</span>
<a name="l00284"></a>00284     <span class="comment">// at SEARCH_RADIUS distance from current vertex AND vertex is not nice</span>
<a name="l00285"></a>00285     <span class="comment">// so max(se) = SEARCH_RADIUS + TARGET_SEPARATION</span>
<a name="l00286"></a>00286     <span class="keywordtype">double</span> max_se = sqrt(<a class="code" href="controls_8h.html#d0624aef9ce60395fe8d18d5da3df9f5">SEARCH_RADIUS_SQ</a>*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>) + <a class="code" href="controls_8h.html#b46ce8f216a9513db67c2b213434e6d0">LOOP_TARGET_SEPARATION</a>*SCALE;
<a name="l00287"></a>00287     <span class="keywordflow">return</span> <a class="code" href="controls_8h.html#33800177cc4bff4c38e6be81afc9ae67">SEPARATION_WEIGHT</a>/2.0*max_se*max_se;
<a name="l00288"></a>00288   }
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a><a class="code" href="classVertex.html#04c9629d846baebc871690f1321c2136">00291</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#04c9629d846baebc871690f1321c2136">Vertex::getEdgeStretchForceEnergy</a> (<span class="keywordtype">double</span> * <span class="keyword">const</span> &amp; force,<span class="keywordtype">bool</span> flag)<span class="keyword"> const</span>
<a name="l00292"></a>00292 <span class="keyword"></span>{
<a name="l00293"></a>00293   <span class="keywordtype">double</span> en_ergy=0;
<a name="l00294"></a>00294   <a class="code" href="meshmorph_8h.html#b8f23ead30535aec0b94acd8c2b32c14">vec_ep</a> e;
<a name="l00295"></a>00295   e.reserve(<a class="code" href="controls_8h.html#526dd339829f063fe1f5b9219792e7be">VECTOR_RESERVE</a>);
<a name="l00296"></a>00296   <a class="code" href="classVertex.html#9698fd8ed0d0ecc74b08d25dfeb483d1">getAdjacentEdges</a>(e);
<a name="l00297"></a>00297   <span class="comment">// for each adjacent edge of current vertex</span>
<a name="l00298"></a>00298   <span class="keywordflow">for</span> (<a class="code" href="meshmorph_8h.html#2c2a5a920658be1c063b7bb97132ad02">ep_it</a> j=e.begin();j!=e.end();j++)
<a name="l00299"></a>00299   {
<a name="l00300"></a>00300     <span class="comment">// compute force and energy of edge</span>
<a name="l00301"></a>00301     en_ergy+=(*j)-&gt;getStretchForceEnergy(<span class="keyword">this</span>,force,flag);
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303   <span class="keywordflow">return</span> en_ergy;
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00306"></a><a class="code" href="classVertex.html#35c911da19dbba9a0b7871bc0a89ee91">00306</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#35c911da19dbba9a0b7871bc0a89ee91">Vertex::getEdgeAngleForceEnergy</a> (<span class="keywordtype">double</span> * <span class="keyword">const</span> &amp;force,<span class="keywordtype">bool</span> flag)<span class="keyword"> const</span>
<a name="l00307"></a>00307 <span class="keyword"></span>{
<a name="l00308"></a>00308   <span class="comment">// NOTE : I previously decided NOT to use nonadjacent edges</span>
<a name="l00309"></a>00309   <span class="comment">// so oe is not being used at this time</span>
<a name="l00310"></a>00310   <a class="code" href="classVertex.html">Vertex</a> *v1=NULL,*v2=NULL,*o1=NULL,*o2=NULL;
<a name="l00311"></a>00311   <a class="code" href="meshmorph_8h.html#b8f23ead30535aec0b94acd8c2b32c14">vec_ep</a> ae,oe;
<a name="l00312"></a>00312   ae.reserve(<a class="code" href="controls_8h.html#526dd339829f063fe1f5b9219792e7be">VECTOR_RESERVE</a>);
<a name="l00313"></a>00313   oe.reserve(<a class="code" href="controls_8h.html#526dd339829f063fe1f5b9219792e7be">VECTOR_RESERVE</a>);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   <span class="comment">// for each adjacent face of current vertex</span>
<a name="l00316"></a>00316   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=f.begin();i!=f.end();i++)
<a name="l00317"></a>00317   {
<a name="l00318"></a>00318     <span class="comment">// for each face edge</span>
<a name="l00319"></a>00319     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;3;j++)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       (*i)-&gt;getEdge(j)-&gt;getVertices(v1,v2,o1,o2);
<a name="l00322"></a>00322       <span class="comment">// if either edge vertex is current vertex</span>
<a name="l00323"></a>00323       <span class="keywordflow">if</span>(v1==<span class="keyword">this</span> || v2==<span class="keyword">this</span>)
<a name="l00324"></a>00324       {
<a name="l00325"></a>00325         <span class="comment">// add edge to adjacent edge vector, ae</span>
<a name="l00326"></a>00326         ae.push_back((*i)-&gt;getEdge(j));
<a name="l00327"></a>00327       }
<a name="l00328"></a>00328       <span class="keywordflow">else</span>
<a name="l00329"></a>00329       {
<a name="l00330"></a>00330         <span class="comment">// add edge to non-adjacent edge vector, oe</span>
<a name="l00331"></a>00331         oe.push_back((*i)-&gt;getEdge(j));
<a name="l00332"></a>00332       }
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335   <span class="comment">// keep unique edges</span>
<a name="l00336"></a>00336   sort(ae.begin(),ae.end());
<a name="l00337"></a>00337   ae.assign(ae.begin(),unique(ae.begin(),ae.end()));
<a name="l00338"></a>00338   sort(oe.begin(),oe.end());
<a name="l00339"></a>00339   oe.assign(oe.begin(),unique(oe.begin(),oe.end()));
<a name="l00340"></a>00340   <span class="comment">// for each adjacent edge</span>
<a name="l00341"></a>00341   <span class="keywordtype">double</span> en_ergy=0;
<a name="l00342"></a>00342   <span class="keywordflow">for</span> (<a class="code" href="meshmorph_8h.html#2c2a5a920658be1c063b7bb97132ad02">ep_it</a> i=ae.begin();i!=ae.end();i++)
<a name="l00343"></a>00343   {
<a name="l00344"></a>00344     <span class="comment">// force and energy contribution</span>
<a name="l00345"></a>00345     en_ergy+=(*i)-&gt;getAngleReForceEnergy(force,flag);
<a name="l00346"></a>00346   }
<a name="l00347"></a>00347   <span class="keywordflow">return</span> en_ergy;
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a><a class="code" href="classVertex.html#45bf5e9132f2e41e1766f5bc635df5a2">00350</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#45bf5e9132f2e41e1766f5bc635df5a2">Vertex::getAdjFaceIntForce</a> (<span class="keywordtype">double</span> * <span class="keyword">const</span> &amp; force)<span class="keyword"> const</span>
<a name="l00351"></a>00351 <span class="keyword"></span>{
<a name="l00352"></a>00352   <span class="comment">// for each adjacent face of current vertex</span>
<a name="l00353"></a>00353   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=f.begin();i!=f.end();i++)
<a name="l00354"></a>00354   {
<a name="l00355"></a>00355     <span class="comment">// if adjacent face is intersected</span>
<a name="l00356"></a>00356     <span class="keywordflow">if</span>(<a class="code" href="classIntersecting__Faces.html#8ccec8bb3cfc50e4ad98ff13c1f8ec8f">Intersecting_Faces::instance</a>().faceIsIntersectedLHS(*i)==<span class="keyword">true</span>)
<a name="l00357"></a>00357     {
<a name="l00358"></a>00358       <span class="comment">// add intersection_force</span>
<a name="l00359"></a>00359       <a class="code" href="classIntersecting__Faces.html#8ccec8bb3cfc50e4ad98ff13c1f8ec8f">Intersecting_Faces::instance</a>().<a class="code" href="classIntersecting__Faces.html#3def09e209230ee7192742008c9dde0c">getFaceIntersectionForce</a>(*i,force);
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361   }
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a><a class="code" href="classVertex.html#b8c6c8e1550c11df21bbf890cd7f5652">00364</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#b8c6c8e1550c11df21bbf890cd7f5652">Vertex::getTotalForceEnergy</a> (<span class="keywordtype">double</span> * <span class="keyword">const</span> &amp;force)<span class="keyword"> const</span>
<a name="l00365"></a>00365 <span class="keyword"></span>{
<a name="l00367"></a>00367   <span class="comment">// true -&gt; compute force</span>
<a name="l00368"></a>00368   <a class="code" href="classVertex.html#8f644e80776c6065ce7f5196f106c387">getSeparationForceEnergy</a>(force,<span class="keyword">true</span>);
<a name="l00369"></a>00369   <span class="comment">// DEBUG</span>
<a name="l00370"></a>00370   <span class="keywordflow">if</span> (<span class="keyword">false</span>) {cout &lt;&lt; <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#c3ac0ef8e13fb01215064cd9bd24ff85">o</a>.size() &lt;&lt; endl;}
<a name="l00371"></a>00371   <span class="keywordtype">bool</span> print_switch = <span class="keyword">false</span>;
<a name="l00372"></a>00372   <span class="keywordtype">double</span> fmag = 0.0;
<a name="l00373"></a>00373   <span class="keywordtype">double</span> f_old[3];
<a name="l00374"></a>00374   f_old[0] = force[0];
<a name="l00375"></a>00375   f_old[1] = force[1];
<a name="l00376"></a>00376   f_old[2] = force[2];
<a name="l00377"></a>00377   <span class="keywordflow">if</span>(print_switch==<span class="keyword">true</span>)
<a name="l00378"></a>00378   {
<a name="l00379"></a>00379     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: force ["</span>
<a name="l00380"></a>00380           &lt;&lt; force[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00381"></a>00381           &lt;&lt; force[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00382"></a>00382           &lt;&lt; force[2] &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00383"></a>00383   }
<a name="l00384"></a>00384   <span class="comment">// DEBUG</span>
<a name="l00385"></a>00385   <span class="keywordflow">if</span>(print_switch==<span class="keyword">true</span>)
<a name="l00386"></a>00386   {
<a name="l00387"></a>00387     <span class="keywordtype">double</span> diff = sqrt(<a class="code" href="misc_8cc.html#aa2064e9e93d580841bffe746925cc8f">dot</a>(force,force))-fmag;
<a name="l00388"></a>00388     fmag = fmag+diff;
<a name="l00389"></a>00389     f_old[0] = force[0];
<a name="l00390"></a>00390     f_old[1] = force[1];
<a name="l00391"></a>00391     f_old[2] = force[2];
<a name="l00392"></a>00392     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: sep force       ["</span>
<a name="l00393"></a>00393           &lt;&lt; force[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00394"></a>00394           &lt;&lt; force[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00395"></a>00395           &lt;&lt; force[2] &lt;&lt; <span class="stringliteral">"]"</span>
<a name="l00396"></a>00396           &lt;&lt; <span class="stringliteral">", diff = "</span> &lt;&lt; diff &lt;&lt; endl;
<a name="l00397"></a>00397   }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">// DEBUG</span>
<a name="l00401"></a>00401 <span class="comment"></span>  <a class="code" href="classVertex.html#04c9629d846baebc871690f1321c2136">getEdgeStretchForceEnergy</a>(force,<span class="keyword">true</span>);
<a name="l00402"></a>00402   <span class="comment">// DEBUG</span>
<a name="l00403"></a>00403   <span class="keywordflow">if</span>(print_switch==<span class="keyword">true</span>)
<a name="l00404"></a>00404   {
<a name="l00405"></a>00405     <span class="keywordtype">double</span> diff = sqrt(<a class="code" href="misc_8cc.html#aa2064e9e93d580841bffe746925cc8f">dot</a>(force,force))-fmag;
<a name="l00406"></a>00406     fmag = fmag+diff;
<a name="l00407"></a>00407     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: stretch force   ["</span>
<a name="l00408"></a>00408           &lt;&lt; force[0]-f_old[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00409"></a>00409           &lt;&lt; force[1]-f_old[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00410"></a>00410           &lt;&lt; force[2]-f_old[2] &lt;&lt; <span class="stringliteral">"]"</span>
<a name="l00411"></a>00411           &lt;&lt; <span class="stringliteral">", diff = "</span> &lt;&lt; diff &lt;&lt; endl;
<a name="l00412"></a>00412     f_old[0] = force[0];
<a name="l00413"></a>00413     f_old[1] = force[1];
<a name="l00414"></a>00414     f_old[2] = force[2];
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416   <span class="comment">// DEBUG</span>
<a name="l00418"></a>00418 <span class="comment"></span>  <a class="code" href="classVertex.html#35c911da19dbba9a0b7871bc0a89ee91">getEdgeAngleForceEnergy</a>(force,<span class="keyword">true</span>);
<a name="l00419"></a>00419   <span class="comment">// DEBUG</span>
<a name="l00420"></a>00420   <span class="keywordflow">if</span>(print_switch==<span class="keyword">true</span>)
<a name="l00421"></a>00421   {
<a name="l00422"></a>00422     <span class="keywordtype">double</span> diff = sqrt(<a class="code" href="misc_8cc.html#aa2064e9e93d580841bffe746925cc8f">dot</a>(force,force))-fmag;
<a name="l00423"></a>00423     fmag = fmag+diff;
<a name="l00424"></a>00424     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: angle force     ["</span>
<a name="l00425"></a>00425           &lt;&lt; force[0]-f_old[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00426"></a>00426           &lt;&lt; force[1]-f_old[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00427"></a>00427           &lt;&lt; force[2]-f_old[2] &lt;&lt; <span class="stringliteral">"]"</span>
<a name="l00428"></a>00428           &lt;&lt; <span class="stringliteral">", diff = "</span> &lt;&lt; diff &lt;&lt; endl;
<a name="l00429"></a>00429     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: resultant force ["</span>
<a name="l00430"></a>00430           &lt;&lt; force[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00431"></a>00431           &lt;&lt; force[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00432"></a>00432           &lt;&lt; force[2] &lt;&lt; <span class="stringliteral">"]\n\n"</span>;
<a name="l00433"></a>00433   }
<a name="l00434"></a>00434   <span class="comment">// DEBUG</span>
<a name="l00436"></a>00436 <span class="comment"></span>  <a class="code" href="classVertex.html#45bf5e9132f2e41e1766f5bc635df5a2">getAdjFaceIntForce</a>(force);
<a name="l00437"></a>00437   <span class="comment">// DEBUG</span>
<a name="l00438"></a>00438   <span class="keywordflow">if</span>(print_switch==<span class="keyword">true</span>)
<a name="l00439"></a>00439   {
<a name="l00440"></a>00440     <span class="keywordtype">double</span> diff = sqrt(<a class="code" href="misc_8cc.html#aa2064e9e93d580841bffe746925cc8f">dot</a>(force,force))-fmag;
<a name="l00441"></a>00441     fmag = fmag+diff;
<a name="l00442"></a>00442     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: face intersection force     ["</span>
<a name="l00443"></a>00443           &lt;&lt; force[0]-f_old[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00444"></a>00444           &lt;&lt; force[1]-f_old[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00445"></a>00445           &lt;&lt; force[2]-f_old[2] &lt;&lt; <span class="stringliteral">"]"</span>
<a name="l00446"></a>00446           &lt;&lt; <span class="stringliteral">", diff = "</span> &lt;&lt; diff &lt;&lt; endl;
<a name="l00447"></a>00447     cout &lt;&lt; <span class="stringliteral">"Vertex::getTotalForceEnergy: resultant force ["</span>
<a name="l00448"></a>00448           &lt;&lt; force[0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00449"></a>00449           &lt;&lt; force[1] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00450"></a>00450           &lt;&lt; force[2] &lt;&lt; <span class="stringliteral">"]\n\n"</span>;
<a name="l00451"></a>00451   }
<a name="l00452"></a>00452   <span class="comment">// DEBUG</span>
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a><a class="code" href="classVertex.html#6a35c09389eca614975085759a47952e">00455</a> <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> <a class="code" href="classVertex.html#6a35c09389eca614975085759a47952e">Vertex::getNewPos</a> (<span class="keywordtype">double</span> gain)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457   <span class="comment">// get force</span>
<a name="l00458"></a>00458   <span class="keywordtype">double</span> force[3]={0,0,0};
<a name="l00459"></a>00459   <a class="code" href="classVertex.html#b8c6c8e1550c11df21bbf890cd7f5652">getTotalForceEnergy</a>(force);
<a name="l00460"></a>00460   <span class="comment">// compute new vertex coordinates</span>
<a name="l00461"></a>00461   <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> pt(3,0);
<a name="l00462"></a>00462   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;3;k++) { pt[k] = gain*force[k]+p[k]; }
<a name="l00463"></a>00463   <span class="comment">// update container quantities</span>
<a name="l00464"></a>00464   <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#dd0f34291b363413a2134863c279a712">addForce</a>(sqrt(force[0]*force[0]+force[1]*force[1]+force[2]*force[2]));
<a name="l00465"></a>00465   <span class="keywordflow">return</span> pt;
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 
<a name="l00468"></a><a class="code" href="classVertex.html#f5e00a98124f61e7c6877e8b843a50e2">00468</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#f5e00a98124f61e7c6877e8b843a50e2">Vertex::getAdjVertices</a> (<a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> &amp;a)<span class="keyword"> const</span>
<a name="l00469"></a>00469 <span class="keyword"></span>{
<a name="l00470"></a>00470   a.clear();
<a name="l00471"></a>00471   <a class="code" href="meshmorph_8h.html#b8f23ead30535aec0b94acd8c2b32c14">vec_ep</a> e;
<a name="l00472"></a>00472   <a class="code" href="classVertex.html#9698fd8ed0d0ecc74b08d25dfeb483d1">getAdjacentEdges</a>(e);
<a name="l00473"></a>00473   <span class="comment">// for each adjacent edge</span>
<a name="l00474"></a>00474   <span class="keywordflow">for</span> (<a class="code" href="meshmorph_8h.html#2c2a5a920658be1c063b7bb97132ad02">ep_it</a> i=e.begin();i!=e.end();i++)
<a name="l00475"></a>00475   {
<a name="l00476"></a>00476     <a class="code" href="classVertex.html">Vertex</a> *v1=NULL,*v2=NULL,*o1=NULL,*o2=NULL;
<a name="l00477"></a>00477     (*i)-&gt;getVertices(v1,v2,o1,o2);
<a name="l00478"></a>00478     <span class="comment">// find vertex different from self and add different vertex to vector</span>
<a name="l00479"></a>00479     <span class="keywordflow">if</span> (v1!=<span class="keyword">this</span>){a.push_back(v1);}
<a name="l00480"></a>00480     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v2!=<span class="keyword">this</span>) {a.push_back(v2);}
<a name="l00481"></a>00481     <span class="keywordflow">else</span> { printf(<span class="stringliteral">"Error. both vertices of edge are equal to current vertex.\n"</span>); exit(1); }
<a name="l00482"></a>00482   }
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="comment">//void Vertex:: getAdjacentFaces(hashset_f &amp;fset) const</span>
<a name="l00486"></a>00486 <span class="comment">//{</span>
<a name="l00487"></a>00487 <span class="comment">//  vec_ep e;</span>
<a name="l00488"></a>00488 <span class="comment">//  getAdjacentEdges(e);</span>
<a name="l00489"></a>00489 <span class="comment">//  // for each adjacent edge</span>
<a name="l00490"></a>00490 <span class="comment">//  for (ep_it i=e.begin();i!=e.end();i++)</span>
<a name="l00491"></a>00491 <span class="comment">//  {</span>
<a name="l00492"></a>00492 <span class="comment">//    // add edge faces to set</span>
<a name="l00493"></a>00493 <span class="comment">//    fset.insert((*i)-&gt;f1);</span>
<a name="l00494"></a>00494 <span class="comment">//    fset.insert((*i)-&gt;f2);</span>
<a name="l00495"></a>00495 <span class="comment">//  }</span>
<a name="l00496"></a>00496 <span class="comment">//}</span>
<a name="l00497"></a>00497 
<a name="l00498"></a><a class="code" href="classVertex.html#08bdf63722a596fecada59dbc6a2ce67">00498</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#08bdf63722a596fecada59dbc6a2ce67">Vertex::getSqSepDist</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00499"></a>00499 <span class="keyword"></span>{
<a name="l00500"></a>00500   <span class="keywordflow">if</span> (cl==NULL) <span class="keywordflow">return</span> <a class="code" href="controls_8h.html#d0624aef9ce60395fe8d18d5da3df9f5">SEARCH_RADIUS_SQ</a>;
<a name="l00501"></a>00501   <span class="comment">// get closest point</span>
<a name="l00502"></a>00502   <span class="comment">//double pC[3];</span>
<a name="l00503"></a>00503   <span class="comment">//vec_d pC = Container::instance().getNearPtOnFaceToVertex(cl,this);</span>
<a name="l00504"></a>00504   <a class="code" href="meshmorph_8h.html#1f34905de522641c355a51fe9e3f1149">vec_fp</a> fp(1,cl);
<a name="l00505"></a>00505   <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> pp;
<a name="l00506"></a>00506   <span class="keywordtype">double</span> sqd=0.0;
<a name="l00507"></a>00507   <a class="code" href="classFace.html">Face</a> *ncl = NULL;
<a name="l00508"></a>00508   <a class="code" href="classContainer.html#e4646d7b418a9b302db245f074ad8ec5">Container::instance</a>().<a class="code" href="classContainer.html#b2dcd71e2d3a21f3977a9de3c49e99c9">findClosestPtToVertexAmongFaces</a>(<span class="keyword">this</span>,fp,pp,sqd,ncl);
<a name="l00509"></a>00509   <span class="comment">//return (pC[0]-p[0])*(pC[0]-p[0])</span>
<a name="l00510"></a>00510   <span class="comment">//      +(pC[1]-p[1])*(pC[1]-p[1])</span>
<a name="l00511"></a>00511   <span class="comment">//      +(pC[2]-p[2])*(pC[2]-p[2]);</span>
<a name="l00512"></a>00512   <span class="keywordflow">return</span> sqd;
<a name="l00513"></a>00513 }
<a name="l00514"></a>00514 
<a name="l00515"></a><a class="code" href="classVertex.html#e040870740fe8b0c7e86b013914843fe">00515</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#e040870740fe8b0c7e86b013914843fe">Vertex::setNewPos</a> (<a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> <span class="keyword">const</span> &amp; pt)
<a name="l00516"></a>00516 {
<a name="l00517"></a>00517   <span class="keywordtype">double</span> d=0;
<a name="l00519"></a>00519   <a class="code" href="meshmorph_8h.html#a2f71558ba2b448f8c9d69e13a5103be">vec_vp</a> v;
<a name="l00520"></a>00520   <a class="code" href="classVertex.html#f5e00a98124f61e7c6877e8b843a50e2">getAdjVertices</a>(v);
<a name="l00521"></a>00521   <span class="comment">// for each adjacent vertex</span>
<a name="l00522"></a>00522   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#739e6a4d59cef4b66aa367b884b12cb7">vp_it</a> i=v.begin();i!=v.end();i++)
<a name="l00523"></a>00523   {
<a name="l00524"></a>00524     <span class="comment">// if adjacent vertex is indistinguishable from p, then displace p</span>
<a name="l00525"></a>00525     <span class="keywordflow">if</span> ( !<a class="code" href="misc_8cc.html#7db6aafb6cea1e9db8da40c90de56269">distinguishable</a>((*i)-&gt;p[0],pt[0])&amp;&amp;
<a name="l00526"></a>00526          !<a class="code" href="misc_8cc.html#7db6aafb6cea1e9db8da40c90de56269">distinguishable</a>((*i)-&gt;p[1],pt[1])&amp;&amp;
<a name="l00527"></a>00527          !<a class="code" href="misc_8cc.html#7db6aafb6cea1e9db8da40c90de56269">distinguishable</a>((*i)-&gt;p[2],pt[2])){ d=<a class="code" href="controls_8h.html#06b7ca91a439f4edad3563357c58efb3">DOUBLE_EPSILON</a>*<a class="code" href="controls_8h.html#4f159bf187491542eb50806dfdc1110f">SCALE</a>;}
<a name="l00528"></a>00528   }
<a name="l00529"></a>00529   p[0]=pt[0]+d;
<a name="l00530"></a>00530   p[1]=pt[1]+d;
<a name="l00531"></a>00531   p[2]=pt[2]+d;
<a name="l00532"></a>00532 }
<a name="l00533"></a>00533 
<a name="l00534"></a><a class="code" href="classVertex.html#5bba0714f468b8f7baf414de12cf344a">00534</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#5bba0714f468b8f7baf414de12cf344a">Vertex::getBoundingBox</a> (<span class="keywordtype">double</span> * <span class="keyword">const</span> &amp; bb)<span class="keyword"> const</span>
<a name="l00535"></a>00535 <span class="keyword"></span>{
<a name="l00536"></a>00536   <span class="comment">// assume bb=bounding box = [xmin xmax ymin ymax zmin zmax]</span>
<a name="l00537"></a>00537   bb[0]=bb[2]=bb[4]=1E30;
<a name="l00538"></a>00538   bb[1]=bb[3]=bb[5]=-1E30;
<a name="l00539"></a>00539   <span class="comment">// for each adjacent face</span>
<a name="l00540"></a>00540   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=f.begin();i!=f.end();i++)
<a name="l00541"></a>00541   {
<a name="l00542"></a>00542     <span class="comment">// for each vertex of face</span>
<a name="l00543"></a>00543     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;3;j++)
<a name="l00544"></a>00544     {
<a name="l00545"></a>00545       <a class="code" href="classVertex.html">Vertex</a> *vv=(*i)-&gt;getVertex(j);
<a name="l00546"></a>00546       <span class="keywordflow">if</span>      (vv-&gt;p[0]&lt;bb[0]){bb[0]=vv-&gt;p[0];}
<a name="l00547"></a>00547       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vv-&gt;p[0]&gt;bb[1]){bb[1]=vv-&gt;p[0];}
<a name="l00548"></a>00548       <span class="keywordflow">if</span>      (vv-&gt;p[1]&lt;bb[2]){bb[2]=vv-&gt;p[1];}
<a name="l00549"></a>00549       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vv-&gt;p[1]&gt;bb[3]){bb[3]=vv-&gt;p[1];}
<a name="l00550"></a>00550       <span class="keywordflow">if</span>      (vv-&gt;p[2]&lt;bb[4]){bb[4]=vv-&gt;p[2];}
<a name="l00551"></a>00551       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vv-&gt;p[2]&gt;bb[5]){bb[5]=vv-&gt;p[2];}
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553   }
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a><a class="code" href="classVertex.html#9698fd8ed0d0ecc74b08d25dfeb483d1">00556</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#9698fd8ed0d0ecc74b08d25dfeb483d1">Vertex::getAdjacentEdges</a> (<a class="code" href="meshmorph_8h.html#b8f23ead30535aec0b94acd8c2b32c14">vec_ep</a> &amp;vec)<span class="keyword"> const</span>
<a name="l00557"></a>00557 <span class="keyword"></span>{
<a name="l00558"></a>00558   vec.clear();
<a name="l00559"></a>00559   <span class="comment">// for each adjacent face</span>
<a name="l00560"></a>00560   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=f.begin();i!=f.end();i++)
<a name="l00561"></a>00561   {
<a name="l00562"></a>00562     <span class="comment">// for each face edge</span>
<a name="l00563"></a>00563     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;3;j++)
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565       <a class="code" href="classVertex.html">Vertex</a> *v1=NULL,*v2=NULL,*o1=NULL,*o2=NULL;
<a name="l00566"></a>00566       (*i)-&gt;getEdge(j)-&gt;getVertices(v1,v2,o1,o2);
<a name="l00567"></a>00567       <span class="comment">// if either edge vertex is current vertex</span>
<a name="l00568"></a>00568       <span class="keywordflow">if</span>(v1==<span class="keyword">this</span> || v2==<span class="keyword">this</span>)
<a name="l00569"></a>00569       {
<a name="l00570"></a>00570         <span class="comment">// add edge to vector</span>
<a name="l00571"></a>00571         vec.push_back((*i)-&gt;getEdge(j));
<a name="l00572"></a>00572       }
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574   }
<a name="l00575"></a>00575 }
<a name="l00576"></a>00576 
<a name="l00577"></a><a class="code" href="classVertex.html#9ed4ff6363eac552ef069cb11c2b8642">00577</a> <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> <span class="keyword">const</span> * <a class="code" href="classVertex.html#9ed4ff6363eac552ef069cb11c2b8642">Vertex::getPos</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00578"></a>00578 <span class="keyword"></span>{
<a name="l00579"></a>00579   <span class="keywordflow">return</span> &amp;p;
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a><a class="code" href="classVertex.html#ecaaf6dcf64506a27218cb7a173cf6dd">00582</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#ecaaf6dcf64506a27218cb7a173cf6dd">Vertex::setPos</a> (<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c)
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584   p[0] = a;
<a name="l00585"></a>00585   p[1] = b;
<a name="l00586"></a>00586   p[2] = c;
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 
<a name="l00589"></a><a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">00589</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">Vertex::getCoord</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00590"></a>00590 <span class="keyword"></span>{
<a name="l00591"></a>00591   <span class="keywordflow">return</span> p[i];
<a name="l00592"></a>00592 }
<a name="l00593"></a>00593 
<a name="l00594"></a><a class="code" href="classVertex.html#523766c0ba54083986420f0fe2e60036">00594</a> <a class="code" href="classFace.html">Face</a> <span class="keyword">const</span> * <a class="code" href="classVertex.html#523766c0ba54083986420f0fe2e60036">Vertex::getFace</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00595"></a>00595 <span class="keyword"></span>{
<a name="l00596"></a>00596   <span class="keywordflow">return</span> cl;
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a><a class="code" href="classVertex.html#e10e68892964abdcf02212da4e326e9a">00599</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#e10e68892964abdcf02212da4e326e9a">Vertex::setFace</a> (<a class="code" href="classFace.html">Face</a> * <span class="keyword">const</span> ff)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601   cl=ff;
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a><a class="code" href="classVertex.html#9f5e25fd8be3ea577b4fc36069e1179d">00604</a> <a class="code" href="classObject.html">Object</a> <span class="keyword">const</span> * <a class="code" href="classVertex.html#9f5e25fd8be3ea577b4fc36069e1179d">Vertex::getObject</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00605"></a>00605 <span class="keyword"></span>{
<a name="l00606"></a>00606   <span class="keywordflow">return</span> o;
<a name="l00607"></a>00607 }
<a name="l00608"></a>00608 
<a name="l00609"></a><a class="code" href="classVertex.html#993abbc895f398fdae0fac89d52ebb04">00609</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#993abbc895f398fdae0fac89d52ebb04">Vertex::setObject</a> (<a class="code" href="classObject.html">Object</a> * <span class="keyword">const</span> oo)
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611   o=oo;
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00614"></a><a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">00614</a> <a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> <a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">Vertex::begin</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00615"></a>00615 <span class="keyword"></span>{
<a name="l00616"></a>00616   <span class="keywordflow">return</span> f.begin();
<a name="l00617"></a>00617 }
<a name="l00618"></a>00618 
<a name="l00619"></a><a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">00619</a> <a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> <a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">Vertex::end</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00620"></a>00620 <span class="keyword"></span>{
<a name="l00621"></a>00621   <span class="keywordflow">return</span> f.end();
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a><a class="code" href="classVertex.html#b3fd4720d00b7efd39cf2c01315eabf1">00624</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#b3fd4720d00b7efd39cf2c01315eabf1">Vertex::addAdjacentFace</a> (<a class="code" href="classFace.html">Face</a> *ff)
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626   f.push_back(ff);
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a><a class="code" href="classVertex.html#3ee79c5a1eefd73147d1e7cf8cdd2d14">00629</a> <a class="code" href="classFace.html">Face</a>* <a class="code" href="classVertex.html#3ee79c5a1eefd73147d1e7cf8cdd2d14">Vertex::getAdjacentFace</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00630"></a>00630 <span class="keyword"></span>{
<a name="l00631"></a>00631   <span class="keywordflow">return</span> f[i];
<a name="l00632"></a>00632 }
<a name="l00633"></a>00633 
<a name="l00634"></a><a class="code" href="classVertex.html#b01da7ba35653cce77dfd96d3ec04872">00634</a> <span class="keywordtype">int</span> <a class="code" href="classVertex.html#b01da7ba35653cce77dfd96d3ec04872">Vertex::getNumAdjFaces</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00635"></a>00635 <span class="keyword"></span>{
<a name="l00636"></a>00636   <span class="keywordflow">return</span> f.size();
<a name="l00637"></a>00637 }
<a name="l00638"></a>00638 
<a name="l00639"></a><a class="code" href="classVertex.html#33ec689fc3b54c151218b450a36c9440">00639</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#33ec689fc3b54c151218b450a36c9440">Vertex::sortAdjacentFaces</a> (<span class="keywordtype">void</span>)
<a name="l00640"></a>00640 {
<a name="l00641"></a>00641   sort(f.begin(),f.end());
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a><a class="code" href="classVertex.html#6da43553ec4bb04bc2eba8ff3da85574">00644</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#6da43553ec4bb04bc2eba8ff3da85574">Vertex::getEnergy</a> (<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00645"></a>00645 <span class="keyword"></span>{
<a name="l00646"></a>00646   <span class="keywordflow">return</span> energy;
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a><a class="code" href="classVertex.html#51420da58bf0b101f01ba792071f33d6">00649</a> <span class="keywordtype">void</span> <a class="code" href="classVertex.html#51420da58bf0b101f01ba792071f33d6">Vertex::setEnergy</a> (<span class="keywordtype">double</span> ee)
<a name="l00650"></a>00650 {
<a name="l00651"></a>00651   energy = ee;
<a name="l00652"></a>00652 }
<a name="l00653"></a>00653 
<a name="l00654"></a><a class="code" href="classVertex.html#e13f2f61b69d0528e08fb79c3e124361">00654</a> <span class="keywordtype">bool</span> <a class="code" href="classVertex.html#e13f2f61b69d0528e08fb79c3e124361">Vertex::faceIsAdjacent</a> (<a class="code" href="classFace.html">Face</a> <span class="keyword">const</span> * <span class="keyword">const</span> ff)<span class="keyword"> const</span>
<a name="l00655"></a>00655 <span class="keyword"></span>{
<a name="l00656"></a>00656   <span class="keywordflow">return</span> binary_search(f.begin(),f.end(),ff);
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 
<a name="l00659"></a><a class="code" href="classVertex.html#d9fce6dd07b9f8053a0ee2f1dbfeba77">00659</a> <span class="keywordtype">double</span> <a class="code" href="classVertex.html#d9fce6dd07b9f8053a0ee2f1dbfeba77">Vertex::getSqVirtualDisp</a> (<span class="keywordtype">double</span> gain)
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661   <span class="comment">// compute new vertex coords</span>
<a name="l00662"></a>00662   <span class="comment">// q = new holding position coordinates (x,y,z)</span>
<a name="l00663"></a>00663   <a class="code" href="meshmorph_8h.html#db0ab3db1ab685e2d2bff657e3e86861">vec_d</a> q = <a class="code" href="classVertex.html#6a35c09389eca614975085759a47952e">getNewPos</a>(gain);
<a name="l00664"></a>00664   <span class="keywordflow">return</span> (q[0]-<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(0))*(q[0]-<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(0))+
<a name="l00665"></a>00665          (q[1]-<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(1))*(q[1]-<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(1))+
<a name="l00666"></a>00666          (q[2]-<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(2))*(q[2]-<a class="code" href="classVertex.html#e77b7638155ba654b0bee000e8f3eaf2">getCoord</a>(2));
<a name="l00667"></a>00667 }
<a name="l00668"></a>00668 
<a name="l00669"></a><a class="code" href="classVertex.html#3c4e5c26165558d81dc32ea2876e87f6">00669</a> <a class="code" href="classFace.html">Face</a>* <a class="code" href="classVertex.html#3c4e5c26165558d81dc32ea2876e87f6">Vertex::getFaceNotAdjToVertex</a> (<a class="code" href="classVertex.html">Vertex</a> <span class="keyword">const</span> * <span class="keyword">const</span> cv)<span class="keyword"> const</span>
<a name="l00670"></a>00670 <span class="keyword"></span>{
<a name="l00671"></a>00671   <span class="comment">// for each adjacent face of tv</span>
<a name="l00672"></a>00672   <span class="keywordflow">for</span>(<a class="code" href="meshmorph_8h.html#8d2bcc70fbd9a2cca7eecb128703e8c7">fp_cit</a> i=<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>();i!=<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>();i++)
<a name="l00673"></a>00673   {
<a name="l00674"></a>00674     <span class="comment">// if face is not adjacent to vertex cv</span>
<a name="l00675"></a>00675     <span class="keywordflow">if</span>(binary_search(cv-&gt;<a class="code" href="classVertex.html#7ebc259c68c71408ecc67662d64e9ec0">begin</a>(),cv-&gt;<a class="code" href="classVertex.html#4bb81e4284f35a668f19495419a23abb">end</a>(),*i)==<span class="keyword">false</span>)
<a name="l00676"></a>00676     {
<a name="l00677"></a>00677       <span class="keywordflow">return</span> *i;
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679   }
<a name="l00680"></a>00680   cout &lt;&lt; <span class="stringliteral">"Vertex::getFaceNotAdjToVertex: Error:"</span>
<a name="l00681"></a>00681         &lt;&lt; <span class="stringliteral">"no acceptable face was found!\n"</span>;
<a name="l00682"></a>00682   exit(0);
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Jul 18 19:43:40 2008 for meshmorph by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
